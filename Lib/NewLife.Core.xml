<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NewLife.Core</name>
    </assembly>
    <members>
        <member name="T:NewLife.Log.WriteLogEventArgs">
            <summary>
            写日志事件参数
            </summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message">日志</param>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message">日志</param>
            <param name="exception">异常</param>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Message">
            <summary>日志信息</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Exception">
            <summary>异常</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadID">
            <summary>线程编号</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsPoolThread">
            <summary>是否线程池线程</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadName">
            <summary>线程名</summary>
        </member>
        <member name="T:NewLife.IO.BinaryReaderX">
            <summary>
            二进制协议读取器
            </summary>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.#ctor(System.IO.Stream)">
            <summary>
            构造
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadEncodedInt16">
            <summary>
            以压缩格式读取16位整数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadEncodedInt32">
            <summary>
            以压缩格式读取32位整数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadEncodedInt64">
            <summary>
            以压缩格式读取64位整数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.Support(System.Type)">
            <summary>
            是否支持指定类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadObject(System.Type)">
            <summary>
            从数据流中读取指定类型的对象
            </summary>
            <param name="type">类型</param>
            <returns>对象</returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.TryReadObject(System.Type,System.Object@)">
            <summary>
            尝试读取目标对象指定成员的值
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.TryReadObject(System.Object,NewLife.Reflection.MemberInfoX,System.Type,System.Boolean,System.Boolean,System.Boolean,System.Object@)">
            <summary>
            尝试读取目标对象指定成员的值，通过委托方法递归处理成员
            </summary>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="type">成员类型，以哪一种类型读取</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="value">成员值</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.TryReadObject(System.Object,NewLife.Reflection.MemberInfoX,System.Type,System.Boolean,System.Boolean,System.Boolean,System.Object@,NewLife.IO.BinaryReaderX.ReadCallback)">
            <summary>
            尝试读取目标对象指定成员的值，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员
            </summary>
            <remarks>
            简单类型在value中返回，复杂类型直接填充target；
            </remarks>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="type">成员类型，以哪一种类型读取</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="value">成员值</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadValue(System.Type,System.Boolean)">
            <summary>
            读取值类型数据
            </summary>
            <param name="type"></param>
            <param name="encodeInt"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.TryReadValue(System.Type,System.Boolean,System.Object@)">
            <summary>
            尝试读取值类型数据，返回是否读取成功
            </summary>
            <param name="type"></param>
            <param name="encodeInt"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.TryReadEnumerable(System.Type,System.Object@)">
            <summary>
            尝试读取目标对象指定成员的值
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.TryReadEnumerable(System.Object,NewLife.Reflection.MemberInfoX,System.Boolean,System.Boolean,System.Boolean,System.Object@)">
            <summary>
            尝试读取枚举
            </summary>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="value">成员值</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.TryReadEnumerable(System.Object,NewLife.Reflection.MemberInfoX,System.Boolean,System.Boolean,System.Boolean,System.Object@,NewLife.IO.BinaryReaderX.ReadCallback)">
            <summary>
            尝试读取枚举
            </summary>
            <remarks>重点和难点在于如果得知枚举元素类型，这里假设所有元素类型一致，否则实在无法处理</remarks>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="value">成员值</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.TryReadEnumerable(System.Type,System.Type[],System.Boolean,System.Boolean,System.Boolean,System.Object@,NewLife.IO.BinaryReaderX.ReadCallback)">
            <summary>
            尝试读取枚举
            </summary>
            <remarks>重点和难点在于如果得知枚举元素类型，这里假设所有元素类型一致，否则实在无法处理</remarks>
            <param name="type">类型</param>
            <param name="elementTypes">元素类型数组</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="value">成员值</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.TryReadX(System.Type,System.Object@)">
            <summary>
            扩展读取，反射查找合适的读取方法
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadGuid">
            <summary>
            读取Guid
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadIPAddress">
            <summary>
            读取IPAddress
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadIPEndPoint">
            <summary>
            读取IPEndPoint
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryReaderX.ReadType">
            <summary>
            读取Type
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.IO.BinaryReaderX.Encoding">
            <summary>编码</summary>
        </member>
        <member name="T:NewLife.IO.BinaryReaderX.ReadCallback">
            <summary>
            数据读取方法
            </summary>
            <param name="reader">读取器</param>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="type">成员类型，以哪一种类型读取</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="value">成员值</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="T:NewLife.Remoting.EntityMessage">
            <summary>
            实体消息
            </summary>
        </member>
        <member name="T:NewLife.Remoting.RemotingMessage">
            <summary>
            远程消息
            </summary>
        </member>
        <member name="T:NewLife.Messaging.Message">
            <summary>
            消息基类
            </summary>
        </member>
        <member name="T:NewLife.IO.BinaryAccessor">
            <summary>
            二进制数据访问器
            </summary>
        </member>
        <member name="T:NewLife.Reflection.FastIndexAccessor">
            <summary>
            快速索引器接口的默认实现
            </summary>
        </member>
        <member name="T:NewLife.Reflection.IIndexAccessor">
            <summary>
            索引器接访问口。
            该接口用于通过名称快速访问对象属性或字段（属性优先）。
            </summary>
        </member>
        <member name="P:NewLife.Reflection.IIndexAccessor.Item(System.String)">
            <summary>
            获取/设置 指定名称的属性或字段的值
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.GetValue(System.Object,System.String)">
            <summary>
            获取目标对象指定属性字段的值
            </summary>
            <param name="target">目标对象</param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.TryGetValue(System.Object,System.String,System.Object@)">
            <summary>
            尝试获取目标对象指定属性字段的值，返回是否成功
            </summary>
            <param name="target">目标对象</param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.GetValue``1(System.String)">
            <summary>
            获取目标对象指定属性字段的值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.TryGetValue``1(System.String,``0@)">
            <summary>
            尝试获取目标对象指定属性字段的值，返回是否成功
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.SetValue(System.Object,System.String,System.Object)">
            <summary>
            设置目标对象指定属性字段的值
            </summary>
            <param name="target">目标对象</param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.FastIndexAccessor.TrySetValue(System.Object,System.String,System.Object)">
            <summary>
            尝试设置目标对象指定属性字段的值，返回是否成功
            </summary>
            <param name="target">目标对象</param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.FastIndexAccessor.Item(System.String)">
            <summary>
            获取/设置 字段值。
            一个索引，反射实现。
            派生实体类可重写该索引，以避免发射带来的性能损耗
            </summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.IBinaryAccessor">
            <summary>
            二进制数据访问器接口，用于把对象数据写入到写入器，或者从读取器中读取数据到对象
            </summary>
        </member>
        <member name="M:NewLife.IO.IBinaryAccessor.Read(NewLife.IO.BinaryReaderX)">
            <summary>
            从读取器中读取数据到对象
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:NewLife.IO.IBinaryAccessor.Write(NewLife.IO.BinaryWriterX)">
            <summary>
            把对象数据写入到写入器
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.Read(NewLife.IO.BinaryReaderX)">
            <summary>
            从读取器中读取数据到对象
            </summary>
            <param name="reader">读取器</param>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.ReadMember(NewLife.IO.BinaryReaderX,System.Object,NewLife.Reflection.MemberInfoX,System.Type,System.Boolean,System.Boolean,System.Boolean,System.Object@,NewLife.IO.BinaryReaderX.ReadCallback)">
            <summary>
            尝试读取目标对象指定成员的值，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员
            </summary>
            <remarks>
            简单类型在value中返回，复杂类型直接填充target；
            </remarks>
            <param name="reader">读取器</param>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="type">成员类型，以哪一种类型读取</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="value">成员值</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.CreateInstance(System.Type)">
            <summary>
            创建指定类型的实例
            </summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.Write(NewLife.IO.BinaryWriterX)">
            <summary>
            把对象数据写入到写入器
            </summary>
            <param name="writer">写入器</param>
        </member>
        <member name="M:NewLife.IO.BinaryAccessor.WriteMember(NewLife.IO.BinaryWriterX,System.Object,NewLife.Reflection.MemberInfoX,System.Boolean,System.Boolean,System.Boolean,NewLife.IO.BinaryWriterX.WriteCallback)">
            <summary>
            把对象写入数据流，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员
            </summary>
            <param name="writer">写入器</param>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="F:NewLife.Messaging.Message.StreamHandlerName">
            <summary>
            数据流处理器名称
            </summary>
        </member>
        <member name="M:NewLife.Messaging.Message.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Messaging.Message.Serialize(System.IO.Stream)">
            <summary>
            序列化当前消息到流中
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Messaging.Message.ToArray">
            <summary>
            序列化为字节数组
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.WritePacket(System.IO.Stream)">
            <summary>
            消息序列化后打包，一次性写入指定流，防止数据因序列化中多次写入而分片发出（比如UDP网络）
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Messaging.Message.Deserialize(System.IO.Stream)">
            <summary>
            反序列化
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Messaging.Message.ID">
            <summary>消息唯一编号</summary>
        </member>
        <member name="P:NewLife.Remoting.RemotingMessage.ID">
            <summary>
            消息唯一编码
            </summary>
        </member>
        <member name="P:NewLife.Remoting.RemotingMessage.MessageType">
            <summary>消息类型</summary>
        </member>
        <member name="M:NewLife.Remoting.EntityMessage.#ctor">
            <summary>
            实例化
            </summary>
        </member>
        <member name="M:NewLife.Remoting.EntityMessage.#ctor(System.Object)">
            <summary>
            使用实体对象来实例化
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:NewLife.Remoting.EntityMessage.ReadMember(NewLife.IO.BinaryReaderX,System.Object,NewLife.Reflection.MemberInfoX,System.Type,System.Boolean,System.Boolean,System.Boolean,System.Object@,NewLife.IO.BinaryReaderX.ReadCallback)">
            <summary>
            尝试读取目标对象指定成员的值，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员
            </summary>
            <remarks>
            简单类型在value中返回，复杂类型直接填充target；
            </remarks>
            <param name="reader">读取器</param>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="type">成员类型，以哪一种类型读取</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="value">成员值</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="P:NewLife.Remoting.EntityMessage.MessageType">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Remoting.EntityMessage.EntityType">
            <summary>实体类型</summary>
        </member>
        <member name="P:NewLife.Remoting.EntityMessage.Entity">
            <summary>实体对象</summary>
        </member>
        <member name="T:NewLife.Messaging.MessageExceptionOption">
            <summary>
            消息异常选项
            </summary>
        </member>
        <member name="F:NewLife.Messaging.MessageExceptionOption.Ignore">
            <summary>
            忽略
            </summary>
        </member>
        <member name="F:NewLife.Messaging.MessageExceptionOption.Throw">
            <summary>
            抛出
            </summary>
        </member>
        <member name="F:NewLife.Messaging.MessageExceptionOption.SaveAsMessage">
            <summary>
            保存为异常消息
            </summary>
        </member>
        <member name="T:NewLife.Serialization.IAccessor">
            <summary>
            序列化访问器。接口实现者可以在这里完全自定义行为（返回true），也可以通过设置事件来影响行为（返回false）
            </summary>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.Read(NewLife.Serialization.IReader)">
            <summary>
            从读取器中读取数据到对象。接口实现者可以在这里完全自定义行为（返回true），也可以通过设置事件来影响行为（返回false）
            </summary>
            <param name="reader">读取器</param>
            <returns>是否读取成功，若返回成功读取器将不再读取该对象</returns>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.ReadComplete(NewLife.Serialization.IReader,System.Boolean)">
            <summary>
            从读取器中读取数据到对象后执行。接口实现者可以在这里取消Read阶段设置的事件
            </summary>
            <param name="reader">读取器</param>
            <param name="success">是否读取成功</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.Write(NewLife.Serialization.IWriter)">
            <summary>
            把对象数据写入到写入器。接口实现者可以在这里完全自定义行为（返回true），也可以通过设置事件来影响行为（返回false）
            </summary>
            <param name="writer">写入器</param>
            <returns>是否写入成功，若返回成功写入器将不再读写入对象</returns>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.WriteComplete(NewLife.Serialization.IWriter,System.Boolean)">
            <summary>
            把对象数据写入到写入器后执行。接口实现者可以在这里取消Write阶段设置的事件
            </summary>
            <param name="writer">写入器</param>
            <param name="success">是否写入成功</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="T:NewLife.DisposeBase">
            <summary>
            具有销毁资源处理的抽象基类
            </summary>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose(System.Boolean)">
            <summary>
            释放资源，参数表示是否由Dispose调用。该方法保证OnDispose只被调用一次！
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.DisposeBase.OnDispose(System.Boolean)">
            <summary>
            子类重载实现资源释放逻辑时必须首先调用基类方法
            </summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="M:NewLife.DisposeBase.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:NewLife.DisposeBase.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="T:NewLife.Security.Crc32">
             <summary>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </summary>
        </member>
        <member name="F:NewLife.Security.Crc32.crc">
            <summary>
            The crc data checksum so far.
            </summary>
        </member>
        <member name="M:NewLife.Security.Crc32.Reset">
            <summary>
            Resets the CRC32 data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Byte[])">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="P:NewLife.Security.Crc32.Value">
            <summary>
            Returns the CRC32 data checksum computed so far.
            </summary>
        </member>
        <member name="T:NewLife.Serialization.WriteIndexEventArgs">
            <summary>
            写入序数事件参数
            </summary>
        </member>
        <member name="T:NewLife.Serialization.WriterEventArgs">
            <summary>
            写入器时间参数
            </summary>
        </member>
        <member name="T:NewLife.Serialization.ReaderWriterEventArgs">
            <summary>
            读写器事件参数
            </summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterEventArgs.Success">
            <summary>是否成功。</summary>
        </member>
        <member name="M:NewLife.Serialization.WriterEventArgs.#ctor(NewLife.Serialization.WriteObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.WriterEventArgs.Callback">
            <summary>处理成员的委托</summary>
        </member>
        <member name="M:NewLife.Serialization.WriteIndexEventArgs.#ctor(System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="index">成员序号</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.WriteIndexEventArgs.Index">
            <summary>成员序号</summary>
        </member>
        <member name="T:NewLife.Remoting.RemotingMessageType">
            <summary>
            远程消息类型
            </summary>
        </member>
        <member name="F:NewLife.Remoting.RemotingMessageType.Method">
            <summary>
            方法消息
            </summary>
        </member>
        <member name="F:NewLife.Remoting.RemotingMessageType.Entity">
            <summary>
            实体消息
            </summary>
        </member>
        <member name="T:NewLife.Reflection.AssemblyX">
            <summary>
            程序集辅助类。使用Create创建，保证每个程序集只有一个辅助类
            </summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.Create(System.Reflection.Assembly)">
            <summary>
            创建程序集辅助对象
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetCustomAttribute``1">
            <summary>
            获取自定义属性
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetCustomAttributeValue``2">
            <summary>
            获取自定义属性的值。可用于ReflectionOnly加载的程序集
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindPlugins``1">
            <summary>
            查找插件
            </summary>
            <typeparam name="TPlugin"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindPlugins(System.Type)">
            <summary>
            查找插件，带缓存
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindAllPlugins(System.Type)">
            <summary>
            查找所有非系统程序集中的所有插件
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindAllPlugins(System.Type,System.Boolean)">
            <summary>
            查找所有非系统程序集中的所有插件
            </summary>
            <param name="type"></param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetAssemblies(System.AppDomain)">
            <summary>
            获取指定程序域所有程序集的辅助类
            </summary>
            <param name="domain"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetAssemblies">
            <summary>
            获取当前程序域所有程序集的辅助类
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyGetAssemblies(System.AppDomain)">
            <summary>
            只反射加载有效路径（应用程序是当前路径，Web是Bin目录）的所有程序集
            </summary>
            <param name="domain"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyGetAssemblies">
            <summary>
            获取当前程序域所有程序集的辅助类
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyLoad(System.String)">
            <summary>
            只反射加载指定路径的所有程序集
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyLoad">
            <summary>
            只反射加载有效路径（应用程序是当前路径，Web是Bin目录）的所有程序集
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.Equal(System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            判断两个程序集是否相同，避免引用加载和执行上下文加载的相同程序集显示不同
            </summary>
            <param name="asm1"></param>
            <param name="asm2"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Asm">
            <summary>程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Version">
            <summary>
            程序集版本
            </summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Title">
            <summary>程序集标题</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.FileVersion">
            <summary>
            文件版本
            </summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Compile">
            <summary>编译时间</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Company">
            <summary>公司名称</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Description">
            <summary>说明</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Location">
            <summary>
            获取包含清单的已加载文件的路径或 UNC 位置。
            </summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Types">
            <summary>类型集合，当前程序集的所有类型</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.TypeXs">
            <summary>类型集合，当前程序集的所有类型</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.IsSystemAssembly">
            <summary>
            是否系统程序集
            </summary>
        </member>
        <member name="T:NewLife.Serialization.ReadDictionaryEventArgs">
            <summary>
            读取字典项事件参数
            </summary>
        </member>
        <member name="T:NewLife.Serialization.ReadIndexEventArgs">
            <summary>
            读取序数事件参数
            </summary>
        </member>
        <member name="T:NewLife.Serialization.ReaderEventArgs">
            <summary>
            读取器事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.ReaderEventArgs.#ctor(NewLife.Serialization.ReadObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.ReaderEventArgs.Callback">
            <summary>处理成员的委托</summary>
        </member>
        <member name="M:NewLife.Serialization.ReadIndexEventArgs.#ctor(System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="index">成员序号</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.ReadIndexEventArgs.Index">
            <summary>成员序号</summary>
        </member>
        <member name="M:NewLife.Serialization.ReadDictionaryEventArgs.#ctor(System.Collections.DictionaryEntry,System.Type,System.Type,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="value">对象</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="index"></param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.ReadDictionaryEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.ReadDictionaryEventArgs.KeyType">
            <summary>键类型</summary>
        </member>
        <member name="P:NewLife.Serialization.ReadDictionaryEventArgs.ValueType">
            <summary>值类型</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader">
            <summary>
            Json读取器
            </summary>
        </member>
        <member name="T:NewLife.Serialization.TextReaderBase`1">
            <summary>
            字符串类型读取器基类
            </summary>
            <typeparam name="TSettings">设置类</typeparam>
        </member>
        <member name="T:NewLife.Serialization.ReaderBase`1">
            <summary>
            读取器基类
            </summary>
            <remarks>序列化框架的处理顺序为：IAccessor接口 => OnObjectReading事件 => 扩展类型 => 基础类型 => 字典 => 枚举 => 序列化接口 => 自定义对象 => 未知类型 => OnObjectReaded事件</remarks>
            <typeparam name="TSettings">设置类</typeparam>
        </member>
        <member name="T:NewLife.Serialization.ReaderWriterBase`1">
            <summary>
            读写器基类
            </summary>
        </member>
        <member name="T:NewLife.Serialization.IReaderWriter">
            <summary>
            读写器接口
            </summary>
        </member>
        <member name="M:NewLife.Serialization.IReaderWriter.Reset">
            <summary>
            重置
            </summary>
        </member>
        <member name="M:NewLife.Serialization.IReaderWriter.GetMembers(System.Type,System.Object)">
            <summary>
            获取需要序列化的成员
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <returns>需要序列化的成员</returns>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.Name">
            <summary>
            读写器名称
            </summary>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.Stream">
            <summary>
            数据流
            </summary>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.Settings">
            <summary>
            序列化设置
            </summary>
        </member>
        <member name="P:NewLife.Serialization.IReaderWriter.Depth">
            <summary>层次深度。</summary>
        </member>
        <member name="E:NewLife.Serialization.IReaderWriter.OnGotMembers">
            <summary>
            获取指定类型中需要序列化的成员时触发。使用者可以修改、排序要序列化的成员。
            </summary>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.Reset">
            <summary>
            重置
            </summary>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.GetMembers(System.Type,System.Object)">
            <summary>
            获取需要序列化的成员
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <returns>需要序列化的成员</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.OnGetMembers(System.Type,System.Object)">
            <summary>
            获取需要序列化的成员（属性或字段）
            </summary>
            <param name="type">指定类型</param>
            <param name="value">对象</param>
            <returns>需要序列化的成员</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.IsDefault(System.Object,NewLife.Serialization.IObjectMemberInfo)">
            <summary>
            判断一个对象的某个成员是否默认值
            </summary>
            <param name="value"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.OnDispose(System.Boolean)">
            <summary>
            释放资源
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.WriteLog(System.String,System.Object[])">
            <summary>
            调试输出
            </summary>
            <param name="action">操作</param>
            <param name="args">参数</param>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.WriteLog(System.Int32,System.String,System.Object[])">
            <summary>
            调试输出
            </summary>
            <param name="colorIndex">颜色方案</param>
            <param name="action">操作</param>
            <param name="args">参数</param>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.SetDebugIndent(System.Int32)">
            <summary>
            设置调试缩进
            </summary>
            <param name="indent">缩进</param>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterBase`1.SetDebugIndent">
            <summary>
            设置调试缩进
            </summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.Name">
            <summary>读写器名称</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.Stream">
            <summary>数据流。默认实例化一个MemoryStream，设置值时将重置Depth为1</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.Settings">
            <summary>序列化设置</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.NewLife#Serialization#IReaderWriter#Settings">
            <summary>
            序列化设置
            </summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.Depth">
            <summary>层次深度</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterBase`1.UseSize">
            <summary>是否使用大小，如果使用，将在写入数组、集合和字符串前预先写入大小</summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderWriterBase`1.OnGotMembers">
            <summary>
            获取指定类型中需要序列化的成员时触发。使用者可以修改、排序要序列化的成员。
            </summary>
        </member>
        <member name="T:NewLife.Serialization.IReader">
            <summary>
            读取器接口
            </summary>
            <remarks>序列化框架的处理顺序为：IAccessor接口 => OnObjectReading事件 => 扩展类型 => 基础类型 => 字典 => 枚举 => 序列化接口 => 自定义对象 => 未知类型 => OnObjectReaded事件</remarks>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadByte">
            <summary>
            从当前流中读取下一个字节，并使流的当前位置提升 1 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadBytes(System.Int32)">
            <summary>
            从当前流中将 count 个字节读入字节数组，如果count小于0，则先读取字节数组长度。
            </summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadInt16">
            <summary>
            从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadInt32">
            <summary>
            从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadInt64">
            <summary>
            从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadSingle">
            <summary>
            从当前流中读取 4 字节浮点值，并使流的当前位置提升 4 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadDouble">
            <summary>
            从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadChar">
            <summary>
            从当前流中读取下一个字符，并根据所使用的 Encoding 和从流中读取的特定字符，提升流的当前位置。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadChars(System.Int32)">
            <summary>
            从当前流中读取 count 个字符，以字符数组的形式返回数据，并根据所使用的 Encoding 和从流中读取的特定字符，提升当前位置。
            </summary>
            <param name="count">要读取的字符数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadString">
            <summary>
            从当前流中读取一个字符串。字符串有长度前缀，一次 7 位地被编码为整数。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadBoolean">
            <summary>
            从当前流中读取 Boolean 值，并使该流的当前位置提升 1 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadDecimal">
            <summary>
            从当前流中读取十进制数值，并将该流的当前位置提升十六个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadDateTime">
            <summary>
            读取一个时间日期
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadGuid">
            <summary>
            读取Guid
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadIPAddress">
            <summary>
            读取IPAddress
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadIPEndPoint">
            <summary>
            读取IPEndPoint
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadType">
            <summary>
            读取Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试按照指定类型读取目标对象
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadObjRef(System.Type,System.Object@,System.Int32@)">
            <summary>
            读取对象引用。
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="index">引用计数</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadDictionary(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取字典类型对象
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadEnumerable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取枚举类型对象
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadSerializable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取实现了可序列化接口的对象
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IReader.ReadUnKnown(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取未知对象（其它所有方法都无法识别的对象），采用BinaryFormatter或者XmlSerialization
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnObjectReading">
            <summary>
            读对象前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnObjectReaded">
            <summary>
            读对象后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnMemberReading">
            <summary>
            读成员前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnMemberReaded">
            <summary>
            读成员后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnDictionaryReading">
            <summary>
            读字典项前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnDictionaryReaded">
            <summary>
            读字典项后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnItemReading">
            <summary>
            读枚举项前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IReader.OnItemReaded">
            <summary>
            读枚举项后触发。
            </summary>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadByte">
            <summary>
            从当前流中读取下一个字节，并使流的当前位置提升 1 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadBytes(System.Int32)">
            <summary>
            从当前流中将 count 个字节读入字节数组，如果count小于0，则先读取字节数组长度。
            </summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadSByte">
            <summary>
            从此流中读取一个有符号字节，并使流的当前位置提升 1 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadIntBytes(System.Int32)">
            <summary>
            读取整数的字节数组，某些写入器（如二进制写入器）可能需要改变字节顺序
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadInt16">
            <summary>
            从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadInt32">
            <summary>
            从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadInt64">
            <summary>
            从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadUInt16">
            <summary>
            使用 Little-Endian 编码从当前流中读取 2 字节无符号整数，并将流的位置提升 2 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadUInt32">
            <summary>
            从当前流中读取 4 字节无符号整数并使流的当前位置提升 4 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadUInt64">
            <summary>
            从当前流中读取 8 字节无符号整数并使流的当前位置提升 8 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadSingle">
            <summary>
            从当前流中读取 4 字节浮点值，并使流的当前位置提升 4 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDouble">
            <summary>
            从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadChar">
            <summary>
            从当前流中读取下一个字符，并根据所使用的 Encoding 和从流中读取的特定字符，提升流的当前位置。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadChars(System.Int32)">
            <summary>
            从当前流中读取 count 个字符，以字符数组的形式返回数据，并根据所使用的 Encoding 和从流中读取的特定字符，提升当前位置。
            </summary>
            <param name="count">要读取的字符数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadString">
            <summary>
            从当前流中读取一个字符串。字符串有长度前缀，一次 7 位地被编码为整数。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadBoolean">
            <summary>
            从当前流中读取 Boolean 值，并使该流的当前位置提升 1 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDecimal">
            <summary>
            从当前流中读取十进制数值，并将该流的当前位置提升十六个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDateTime">
            <summary>
            读取一个时间日期
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadValue(System.Type)">
            <summary>
            读取值类型数据
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadValue(System.Type,System.Object@)">
            <summary>
            尝试读取值类型数据，返回是否读取成功
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDictionary(System.Type,System.Object@)">
            <summary>
            尝试读取字典类型对象
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDictionary(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取字典类型对象
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDictionary(System.Type,System.Type,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取字典项集合，以读取键值失败作为读完字典项的标识，子类可以重载实现以字典项数量来读取
            </summary>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="count">元素个数</param>
            <param name="callback">处理元素的方法</param>
            <returns>字典项集合</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadDictionaryEntry(System.Type,System.Type,System.Collections.DictionaryEntry@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取字典项
            </summary>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="value">字典项</param>
            <param name="index">元素序号</param>
            <param name="callback">处理元素的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadDictionaryEntry(System.Type,System.Type,System.Collections.DictionaryEntry@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取字典项
            </summary>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="value">字典项</param>
            <param name="index">元素序号</param>
            <param name="callback">处理元素的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.GetDictionaryEntryType(System.Type,System.Type@,System.Type@)">
            <summary>
            取得字典的键值类型，默认只支持获取两个泛型参数的字典的键值类型
            </summary>
            <param name="type">字典类型</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <returns>是否获取成功，如果失败，则字典读取失败</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadEnumerable(System.Type,System.Object@)">
            <summary>
            尝试读取枚举
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadEnumerable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取枚举
            </summary>
            <remarks>重点和难点在于如果得知枚举元素类型，这里假设所有元素类型一致，否则实在无法处理</remarks>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadEnumerable(System.Type,System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取枚举
            </summary>
            <remarks>重点和难点在于如果得知枚举元素类型，这里假设所有元素类型一致，否则实在无法处理</remarks>
            <param name="type">类型</param>
            <param name="elementType">元素类型数组</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadItems(System.Type,System.Type,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取元素集合
            </summary>
            <param name="type"></param>
            <param name="elementType"></param>
            <param name="count">元素个数</param>
            <param name="callback">处理元素的方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadItem(System.Type,System.Object@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取项
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="index">元素序号</param>
            <param name="callback">处理元素的方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadItem(System.Type,System.Object@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取项
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="index">元素序号</param>
            <param name="callback">处理元素的方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ProcessItems(System.Type,System.Type,System.Object@,System.Collections.IList)">
            <summary>
            处理结果集
            </summary>
            <param name="type"></param>
            <param name="elementType"></param>
            <param name="value"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadSerializable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取实现了可序列化接口的对象
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadUnKnown(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取未知对象（其它所有方法都无法识别的对象），采用BinaryFormatter或者XmlSerialization
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadX(System.Type,System.Object@)">
            <summary>
            扩展读取，反射查找合适的读取方法
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadGuid">
            <summary>
            读取Guid
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadGuid">
            <summary>
            读取Guid
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadIPAddress">
            <summary>
            读取IPAddress
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadIPAddress">
            <summary>
            读取IPAddress
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadIPEndPoint">
            <summary>
            读取IPEndPoint
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadIPEndPoint">
            <summary>
            读取IPEndPoint
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadType">
            <summary>
            读取Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadType">
            <summary>
            读取Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.IsExactType(System.Type)">
            <summary>
            获取精确类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.CheckAndReadType(System.String,System.Type,System.Object)">
            <summary>
            检查对象类型与指定写入类型是否一致，若不一致，则先写入类型，以保证读取的时候能够以正确的类型读取。同时返回对象实际类型。
            </summary>
            <param name="action"></param>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.GuessType(System.Type)">
            <summary>
            猜测类型。对于无法读取到对象类型的类型，并且是接口之类的，可以猜测
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObjectType">
            <summary>
            读对象类型
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObject(System.Type)">
            <summary>
            从数据流中读取指定类型的对象
            </summary>
            <param name="type">类型</param>
            <returns>对象</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObject(System.Type,System.Object@)">
            <summary>
            尝试读取目标对象指定成员的值，通过委托方法递归处理成员
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取目标对象指定成员的值，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取目标对象指定成员的值，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadRefObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取引用对象
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObjRef``1(NewLife.Reflection.Func{``0})">
            <summary>
            读取引用对象的包装，能自动从引用对象集合里面读取，如果不存在，则调用委托读取对象，并加入引用对象集合
            </summary>
            <typeparam name="T"></typeparam>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadObjRef(System.Type,System.Object@,System.Int32@)">
            <summary>
            读取对象引用。
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="index">引用计数</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadObjRefIndex">
            <summary>
            读取对象引用计数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.AddObjRef(System.Int32,System.Object)">
            <summary>
            添加对象引用
            </summary>
            <param name="index">引用计数</param>
            <param name="value">对象</param>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadCustomObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取目标对象指定成员的值，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.GetMemberBeforeRead(System.Type,System.Object,NewLife.Serialization.IObjectMemberInfo[],System.Int32)">
            <summary>
            读取成员之前获取要读取的成员，默认是index处的成员，实现者可以重载，改变当前要读取的成员，如果当前成员不在数组里面，则实现者自己跳到下一个可读成员。
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="members">可匹配成员数组</param>
            <param name="index">索引</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.GetMemberByName(NewLife.Serialization.IObjectMemberInfo[],System.String)">
            <summary>
            根据名称，从成员数组中查找成员
            </summary>
            <param name="members">可匹配成员数组</param>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadMember(System.Type,System.Object@,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取成员
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.OnReadMember(System.Type,System.Object@,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取成员
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadSize">
            <summary>
            读取大小
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ReadLengths">
            <summary>
            读取多维数组相关参数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderBase`1.ArrEnum(System.Array,System.Action{System.Int32[]},System.Object)">
            <summary>
            给多维数组赋值
            </summary>
            <param name="arr"></param>
            <param name="func"></param>
            <param name="value"></param>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnObjectReading">
            <summary>
            读对象前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnObjectReaded">
            <summary>
            读对象后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnMemberReading">
            <summary>
            读成员前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnMemberReaded">
            <summary>
            读成员后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnDictionaryReading">
            <summary>
            读字典项前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnDictionaryReaded">
            <summary>
            读字典项后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnItemReading">
            <summary>
            读枚举项前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.ReaderBase`1.OnItemReaded">
            <summary>
            读枚举项后触发。
            </summary>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadByte">
            <summary>
            从当前流中读取下一个字节，并使流的当前位置提升 1 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadBytes(System.Int32)">
            <summary>
            从当前流中将 count 个字节读入字节数组，并使当前位置提升 count 个字节。
            </summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.FromHex(System.String)">
            <summary>
            解密
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadInt16">
            <summary>
            从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadInt32">
            <summary>
            从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadInt64">
            <summary>
            从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadSingle">
            <summary>
            从当前流中读取 4 字节浮点值，并使流的当前位置提升 4 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadDouble">
            <summary>
            从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadChars(System.Int32)">
            <summary>
            从当前流中读取 count 个字符，以字符数组的形式返回数据，并根据所使用的 Encoding 和从流中读取的特定字符，提升当前位置。
            </summary>
            <param name="count">要读取的字符数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadString">
            <summary>
            从当前流中读取一个字符串。字符串有长度前缀，一次 7 位地被编码为整数。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadBoolean">
            <summary>
            从当前流中读取 Boolean 值，并使该流的当前位置提升 1 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadDecimal">
            <summary>
            从当前流中读取十进制数值，并将该流的当前位置提升十六个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadDateTime">
            <summary>
            读取一个时间日期
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.OnReadGuid">
            <summary>
            读取Guid
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.OnReadIPAddress">
            <summary>
            读取IPAddress
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.OnReadIPEndPoint">
            <summary>
            读取IPEndPoint
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.TextReaderBase`1.ReadValue(System.Type,System.Object@)">
            <summary>
            尝试读取值类型数据，返回是否读取成功
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.TextReaderBase`1.UseSize">
            <summary>是否使用大小，如果使用，将在写入数组、集合和字符串前预先写入大小。字符串类型读写器一般带有边界，不需要使用大小</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadByte">
            <summary>
            读取字节
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadBytes(System.Int32)">
            <summary>
            读取字节数组
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadBoolean">
            <summary>
            从当前流位置读取一个布尔型数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadDateTime">
            <summary>
            从当前流位置读取一个日期时间型数据,支持的格式参考ParseDateTimeString的说明
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.TryParseDateTimeString(System.String,System.DateTime@)">
            <summary>
            解析日期时间字符串,可以处理多种日期时间格式,包括JsDateTimeFormats枚举中的格式,以及js中toGMTString()的格式
            </summary>
            <param name="str"></param>
            <param name="ret"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.NUMBER_TYPES">
            <summary>
            数字类型 包括整型和浮点型
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.INTEGER_TYPES">
            <summary>
            整型类型
            </summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNumber``1(System.String,NewLife.Serialization.JsonReader.AtomElementType[])">
            <summary>
            从当前流位置读取一个指定T类型的数字,T应该是int long float double及相关类型
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exceptMsg">断言读取时断言失败的附加异常信息</param>
            <param name="expected">期望的节点类型,和T参数有关,一般浮点数额外有AtomElementType.FLOAT</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNumber``1(System.String,System.Globalization.NumberStyles,System.IConvertible@)">
            <summary>
            从指定字符串中尝试读取指定T类型的数字,T应该是int long float double及相关类型
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <param name="numStyles"></param>
            <param name="result">返回值,可以直接强类型转换或者使用ToXXX转换</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.GetExponentOrNotStyle(System.String,NewLife.Serialization.JsonReader.AtomElementType[],NewLife.Serialization.JsonReader.AtomElementType)">
            <summary>
            从给定的实际原子节点类型中返回对应的数字格式
            </summary>
            <param name="str"></param>
            <param name="expected"></param>
            <param name="actual">实际原子节点类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadInt16">
            <summary>
            从当前流位置读取一个16位长度的整型数字
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadInt32">
            <summary>
            从当前流位置读取一个32位长度的整型数字
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadInt64">
            <summary>
            从当前流位置读取一个64位长度的整型数字
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadSingle">
            <summary>
            从当前流位置读取一个单精度浮点数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadDouble">
            <summary>
            从当前流位置读取一个双精度浮点数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadDecimal">
            <summary>
            从当前流位置读取一个十进制数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadString">
            <summary>
            从当前流位置读取一个字符串
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadChar">
            <summary>
            从当前流位置读取一个字符,如果读到的是字符串,将取第一个字符;如果读到的是数字,将作为Unicode字符处理;或者读到null
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadChars(System.Int32)">
            <summary>
            从当前流位置读取字符数组
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadGuid">
            <summary>
            读取Guid
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadIPAddress">
            <summary>
            读取IP地址
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadIPEndPoint">
            <summary>
            读取IP端口地址
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadEnumerable``1(``0[]@)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadEnumerable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            从当前流位置读取一个枚举类型
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadItem(System.Type,System.Object@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            从当前流位置读取枚举项目
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadSerializable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取实现了序列化接口的类型
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadDictionary(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            从当前流位置读取一个字典类型
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadDictionaryEntry(System.Type,System.Type,System.Collections.DictionaryEntry@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            从当前流位置读取一个字典项
            </summary>
            <param name="keyType"></param>
            <param name="valueType"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.AssertReadNextAtomElement(System.String,NewLife.Serialization.JsonReader.AtomElementType[])">
            <summary>
            断言读取下一个原子元素,返回实际读到的原子元素类型,一般用于断言{}[]:,
            
            要得到具体读取到的值应使用另外一个重载
            </summary>
            <param name="msg">断言失败时的附加异常信息</param>
            <param name="expected">期望的原子元素类型</param>
            <exception cref="T:NewLife.Serialization.JsonReader.JsonReaderAssertException">如果断言失败</exception>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.AssertReadNextAtomElement(System.String,System.String@,NewLife.Serialization.JsonReader.AtomElementType[])">
            <summary>
            断言读取下一个原子元素,返回实际读到的原子元素类型
            
            </summary>
            <param name="msg">断言失败时的附加异常信息</param>
            <param name="str">实际读到的内容,字面值是直接的字符串,字符串类型也是实际的字符串(不包括字符串头尾的双引号)</param>
            <param name="expected">期望的原子元素类型</param>
            <exception cref="T:NewLife.Serialization.JsonReader.JsonReaderAssertException">如果断言失败</exception>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.AssertReadNextAtomElement(System.Boolean,System.String,System.String@,NewLife.Serialization.JsonReader.AtomElementType[])">
            <summary>
            断言读取下一个原子元素,返回实际读到的原子元素类型
            
            可以选择是否仅仅Peek而不移动流位置
            </summary>
            <param name="onlyPeek">是否仅Peek而不移动流位置(不移动到有效值的位置),这将会使str不会返回字符串内容(仅一个双引号)</param>
            <param name="msg"></param>
            <param name="str"></param>
            <param name="expected"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNextAtomElement(System.String@)">
            <summary>
            读取下一个原子元素,非{} []这类复合元素
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNextAtomElement(System.Boolean,System.String@)">
            <summary>
            读取下一个原子元素,非{} []这类复合元素
            </summary>
            <param name="str"></param>
            <param name="onlyPeek">是否仅Peek而不移动流位置(不移动到有效值的位置),这将会使str不会返回字符串内容(仅一个双引号)</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.MoveNextStreamPostition">
            <summary>
            将当前输入流位置向后移动一个字符,并返回读取到的字符
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNextString(System.String@)">
            <summary>
            读取下一个字符串,当前reader流已经在"之后,读取到的字符串应该是不包含结尾的双引号
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNextEscapeChar">
            <summary>
            读取下一个转义字符,流已处于转义符\后
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadNextLiteral(System.Boolean,System.String@)">
            <summary>
            读取下一个字面值,可能是true false null 数字 无法识别,调用时第一个字符一定是一个字面值
            </summary>
            <param name="onlyPeek">是否仅Peek而不移动流位置(不移动到有效值的位置),这将会使str不会返回字符串内容(仅一个双引号)</param>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.SkipNext">
            <summary>
            跳过下一个值,可以是跳过对象声明(以及对象成员名称 成员值声明),数组声明,以及基础类型
            </summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.SkipNext(System.Int32)">
            <summary>
            跳过下面的值,并指定初始复合对象深度,通过提供大于0的初始深度可以跳过一直到 偏移指定深度 的复合对象位置,一般是读取到]或者}符号之后
            </summary>
            <param name="initDepth">初始化复合对象深度,应该是大于等于0的数字,小于0时将不做任何操作</param>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.ComplexObjectDepth">
            <summary>
            复合对象深度,包括自定义对象和字典,主要用于平衡[]{},用于成员数量不一致时
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AUTODETECT_TYPES">
            <summary>
            自动探测类型时断言的原子元素类型
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.MEMBERNAME_EXPECTED_TYPES">
            <summary>
            尝试读取成员时期望的原子元素类型
            </summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            从当前流位置读取一个对象
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadCustomObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            从当前流位置读取一个自定义对象,即{}包括的数据
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ComplexObjectDepthIsOverflow">
            <summary>
            当前解析复合对象深度是否超出,用于避免循环引用可能引起的堆栈溢出,仅在Settings.RepeatedActionType是RepeatedAction.DepthLimit时才可能返回true
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.GetMemberBeforeRead(System.Type,System.Object,NewLife.Serialization.IObjectMemberInfo[],System.Int32)">
            <summary>
            读取当前成员名称
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="members"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.OnReadMember(System.Type,System.Object@,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            从当前流位置读取成员值
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="member"></param>
            <param name="index"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.IsCanCreateInstance">
            <summary>
            返回指定类型是否是可以实例化的,即反序列化时是否是可以实例化的类型,一般用于处理未知类型前
            </summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ReadLengths">
            <summary>
            读取多维数组的维度
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.Reader">
            <summary>读取器</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.Stream">
            <summary>
            数据流。更改数据流后，重置Reader为空，以使用新的数据流
            </summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader.ReservedTypeClass">
            <summary>
            表示类型是无法实例化的类型,用于避免父类CheckAndReadType中的ReadType被执行,因为json的类型标识是另外的格式
            </summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader.AtomElementType">
            <summary>
            原子元素类型
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.NONE">
            <summary>
            无 一般表示结尾
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.BRACE_OPEN">
            <summary>
            大括号开始 {
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.BRACE_CLOSE">
            <summary>
            大括号结束 }
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.BRACKET_OPEN">
            <summary>
            方括号开始 [
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.BRACKET_CLOSE">
            <summary>
            方括号结束 ]
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.COLON">
            <summary>
            冒号 :
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.COMMA">
            <summary>
            逗号 ,
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.STRING">
            <summary>
            字符串 "包含的
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.LITERAL">
            <summary>
            字面值 无法识别的字面值
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.TRUE">
            <summary>
            字面值 true
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.FALSE">
            <summary>
            字面值 false
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.NULL">
            <summary>
            字面值 null
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.NUMBER">
            <summary>
            字面值 数字,非科学计数法表示的
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.NUMBER_EXP">
            <summary>
            字面值 数字,科学计数发表示的
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.FLOAT">
            <summary>
            字面值 浮点数,非科学计数法表示的浮点数
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonReader.AtomElementType.FLOAT_EXP">
            <summary>
            字面值 浮点数,科学计数法表示的浮点数
            </summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader.JsonReaderParseException">
            <summary>
            json reader解析异常,主要是信息格式不正确
            </summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.JsonReaderParseException.#ctor(System.Int64,System.Int64,System.String)">
            <summary>
            构造一个解析异常
            </summary>
            <param name="line">行</param>
            <param name="column">列</param>
            <param name="message">额外的异常信息</param>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderParseException.Line">
            <summary>
            解析异常的行
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderParseException.Column">
            <summary>
            解析异常的列
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderParseException.Message">
            <summary>
            解析异常的详细信息
            </summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader.JsonReaderAssertException">
            <summary>
            json reader断言异常,属于解析异常的一部分,主要是提供的数据不符合约定
            </summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.JsonReaderAssertException.#ctor(System.Int64,System.Int64,NewLife.Serialization.JsonReader.AtomElementType[],NewLife.Serialization.JsonReader.AtomElementType,System.String)">
            <summary>
            构造一个断言异常
            </summary>
            <param name="line"></param>
            <param name="column"></param>
            <param name="expected">期望的节点类型</param>
            <param name="actual">实际节点类型</param>
            <param name="messageInfo">额外的描述信息</param>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.JsonReaderAssertException.FormatMessage(System.Int64,System.Int64,NewLife.Serialization.JsonReader.AtomElementType[],NewLife.Serialization.JsonReader.AtomElementType,System.String)">
            <summary>
            获取相似参数下JsonReaderAssertException类的异常信息,在不需要JsonReaderAssertException异常,但需要异常信息时使用
            </summary>
            <param name="line"></param>
            <param name="column"></param>
            <param name="expected"></param>
            <param name="actual"></param>
            <param name="messageInfo"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderAssertException.MessageInfo">
            <summary>
            断言异常的额外异常信息
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderAssertException.Expected">
            <summary>
            断言期望的元素类型
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderAssertException.Actual">
            <summary>
            断言实际得到的类型,如果期望类型中包含这个类型,即表示错误是非元素基础类型错误,而是由于元素格式不符合理想,比如期望是日期时间格式的字符串
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.JsonReaderAssertException.Message">
            <summary>
            异常信息,包含额外信息
            </summary>
        </member>
        <member name="T:NewLife.Serialization.XSerializationException">
            <summary>
            序列化异常
            </summary>
        </member>
        <member name="T:NewLife.Exceptions.XException">
            <summary>
            X组件异常
            </summary>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.String)">
            <summary>
            初始化
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.String,System.Object[])">
            <summary>
            初始化
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.String,System.Exception)">
            <summary>
            初始化
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.Exception)">
            <summary>
            初始化
            </summary>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.Exceptions.XException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            初始化
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Serialization.XSerializationException.#ctor(NewLife.Serialization.IObjectMemberInfo)">
            <summary>
            初始化
            </summary>
            <param name="member"></param>
        </member>
        <member name="M:NewLife.Serialization.XSerializationException.#ctor(NewLife.Serialization.IObjectMemberInfo,System.String)">
            <summary>
            初始化
            </summary>
            <param name="member"></param>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Serialization.XSerializationException.#ctor(NewLife.Serialization.IObjectMemberInfo,System.String,System.Exception)">
            <summary>
            初始化
            </summary>
            <param name="member"></param>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.Serialization.XSerializationException.#ctor(NewLife.Serialization.IObjectMemberInfo,System.Exception)">
            <summary>
            初始化
            </summary>
            <param name="member"></param>
            <param name="innerException"></param>
        </member>
        <member name="P:NewLife.Serialization.XSerializationException.Member">
            <summary>成员</summary>
        </member>
        <member name="T:NewLife.Serialization.ReaderWriterSetting">
            <summary>
            序列化设置
            </summary>
        </member>
        <member name="F:NewLife.Serialization.ReaderWriterSetting._BaseDateTime">
            <summary>
            编码时间日期的起始时间，固定1970-01-01
            </summary>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterSetting.ConvertDateTimeToInt64(System.DateTime)">
            <summary>
            转换时间为64位整数，默认返回毫秒数,具体返回值取决于DateTimeFormat成员的值
            </summary>
            <param name="value">时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ReaderWriterSetting.ConvertInt64ToDateTime(System.Int64)">
            <summary>
            转换64位整数为时间
            </summary>
            <param name="value">64位整数</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.Encoding">
            <summary>字符串编码</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.UseTypeFullName">
            <summary>是否使用类型全名。类型全名能比程序集唯一名更节省空间</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.UseObjRef">
            <summary>是否使用对象引用</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.AutoFlush">
            <summary>自动刷新输出</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.DateTimeFormat">
            <summary>时间日期格式</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterSetting.BaseDateTime">
            <summary>编码时间日期的起始时间</summary>
        </member>
        <member name="T:NewLife.Serialization.ReaderWriterSetting.DateTimeFormats">
            <summary>
            时间日期格式
            </summary>
        </member>
        <member name="F:NewLife.Serialization.ReaderWriterSetting.DateTimeFormats.Ticks">
            <summary>
            嘀嗒数。相对较精确，但是占用空间较大,非utc时间
            </summary>
        </member>
        <member name="F:NewLife.Serialization.ReaderWriterSetting.DateTimeFormats.Milliseconds">
            <summary>
            毫秒数。Json常用格式.指定时间格式为与UTC时间1970.1.1 0:0:0之间的毫秒数
            </summary>
        </member>
        <member name="F:NewLife.Serialization.ReaderWriterSetting.DateTimeFormats.Seconds">
            <summary>
            秒数。相对较不准确，但占用空间最小，能满足日常要求.指定时间格式为与UTC时间1970.1.1 0:0:0之间的秒数
            </summary>
        </member>
        <member name="T:NewLife.Messaging.ExceptionMessage">
            <summary>
            异常消息
            </summary>
        </member>
        <member name="M:NewLife.Messaging.ExceptionMessage.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Messaging.ExceptionMessage.#ctor(System.Exception)">
            <summary>
            初始化
            </summary>
            <param name="ex"></param>
        </member>
        <member name="P:NewLife.Messaging.ExceptionMessage.ID">
            <summary>
            消息编号
            </summary>
        </member>
        <member name="P:NewLife.Messaging.ExceptionMessage.Error">
            <summary>异常</summary>
        </member>
        <member name="T:NewLife.Serialization.ReadMemberEventArgs">
            <summary>
            读取成员事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.ReadMemberEventArgs.#ctor(System.Object,System.Type,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="value">对象</param>
            <param name="type">对象类型</param>
            <param name="member">成员</param>
            <param name="index">成员序号</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.ReadMemberEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.ReadMemberEventArgs.Type">
            <summary>对象类型</summary>
        </member>
        <member name="P:NewLife.Serialization.ReadMemberEventArgs.Member">
            <summary>成员</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonWriter">
            <summary>
            Json写入器
            </summary>
        </member>
        <member name="T:NewLife.Serialization.TextWriterBase`1">
            <summary>
            字符串类型写入器基类
            </summary>
            <typeparam name="TSettings">设置类</typeparam>
        </member>
        <member name="T:NewLife.Serialization.WriterBase`1">
            <summary>
            写入器基类
            </summary>
            <remarks>序列化框架的处理顺序为：IAccessor接口 => OnObjectWriting事件 => 扩展类型 => 基础类型 => 字典 => 枚举 => 序列化接口 => 自定义对象 => 未知类型 => OnObjectWrited事件</remarks>
            <typeparam name="TSettings">设置类</typeparam>
        </member>
        <member name="T:NewLife.Serialization.IWriter">
            <summary>
            写入器接口
            </summary>
            <remarks>序列化框架的处理顺序为：IAccessor接口 => OnObjectWriting事件 => 扩展类型 => 基础类型 => 字典 => 枚举 => 序列化接口 => 自定义对象 => 未知类型 => OnObjectWrited事件</remarks>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Byte)">
            <summary>
            将一个无符号字节写入
            </summary>
            <param name="value">要写入的无符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Byte[])">
            <summary>
            将字节数组写入，如果设置了UseSize，则先写入数组长度。
            </summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将字节数组部分写入当前流，不写入数组长度。
            </summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="index">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Int16)">
            <summary>
            将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。
            </summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Int32)">
            <summary>
            将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。
            </summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Int64)">
            <summary>
            将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。
            </summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Single)">
            <summary>
            将 4 字节浮点值写入当前流，并将流的位置提升 4 个字节。
            </summary>
            <param name="value">要写入的 4 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Double)">
            <summary>
            将 8 字节浮点值写入当前流，并将流的位置提升 8 个字节。
            </summary>
            <param name="value">要写入的 8 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Char)">
            <summary>
            将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。
            </summary>
            <param name="ch">要写入的非代理项 Unicode 字符。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Char[])">
            <summary>
            将字符数组写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。
            </summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            将字符数组部分写入当前流，并根据所使用的 Encoding（可能还根据向流中写入的特定字符），提升流的当前位置。
            </summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
            <param name="index">chars 中开始写入的起始点。</param>
            <param name="count">要写入的字符数。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.String)">
            <summary>
            写入字符串
            </summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Boolean)">
            <summary>
            将单字节 Boolean 值写入
            </summary>
            <param name="value">要写入的 Boolean 值</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Decimal)">
            <summary>
            将一个十进制值写入当前流，并将流位置提升十六个字节。
            </summary>
            <param name="value">要写入的十进制值。</param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.DateTime)">
            <summary>
            将一个时间日期写入
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Guid)">
            <summary>
            写入Guid
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Net.IPAddress)">
            <summary>
            写入IPAddress
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Net.IPEndPoint)">
            <summary>
            写入IPEndPoint
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Write(System.Type)">
            <summary>
            写入Type
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IWriter.WriteObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入对象。具体读写器可以重载该方法以修改写入对象前后的行为。
            </summary>
            <param name="value">对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IWriter.WriteObjRef(System.Object)">
            <summary>
            写入对象引用。
            </summary>
            <param name="value">对象</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IWriter.WriteDictionary(System.Collections.IDictionary,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入字典类型数据
            </summary>
            <param name="value">字典数据</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IWriter.WriteEnumerable(System.Collections.IEnumerable,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入枚举类型数据
            </summary>
            <param name="value">枚举数据</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IWriter.WriteSerializable(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入实现了可序列化接口的对象
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IWriter.WriteUnKnown(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入未知对象（其它所有方法都无法识别的对象），采用BinaryFormatter或者XmlSerialization
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IWriter.Flush">
            <summary>
            刷新缓存中的数据
            </summary>
        </member>
        <member name="M:NewLife.Serialization.IWriter.ToArray">
            <summary>
            输出数据转为字节数组
            </summary>
            <returns></returns>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnObjectWriting">
            <summary>
            写对象前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnObjectWrited">
            <summary>
            写对象后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnMemberWriting">
            <summary>
            写成员前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnMemberWrited">
            <summary>
            写成员后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnDictionaryWriting">
            <summary>
            写字典项前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnDictionaryWrited">
            <summary>
            写字典项后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnItemWriting">
            <summary>
            写枚举项前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.IWriter.OnItemWrited">
            <summary>
            写枚举项后触发。
            </summary>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Byte)">
            <summary>
            将一个无符号字节写入
            </summary>
            <param name="value">要写入的无符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Byte[])">
            <summary>
            将字节数组写入，如果设置了UseSize，则先写入数组长度。
            </summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.SByte)">
            <summary>
            将一个有符号字节写入当前流，并将流的位置提升 1 个字节。
            </summary>
            <param name="value">要写入的有符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将字节数组部分写入当前流，不写入数组长度。
            </summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="index">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Byte[],System.Int32)">
            <summary>
            写入字节数组，自动计算长度
            </summary>
            <param name="buffer"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteIntBytes(System.Byte[])">
            <summary>
            写入整数的字节数组，某些写入器（如二进制写入器）可能需要改变字节顺序
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Int16)">
            <summary>
            将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。
            </summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Int32)">
            <summary>
            将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。
            </summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Int64)">
            <summary>
            将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。
            </summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.UInt16)">
            <summary>
            将 2 字节无符号整数写入当前流，并将流的位置提升 2 个字节。
            </summary>
            <param name="value">要写入的 2 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.UInt32)">
            <summary>
            将 4 字节无符号整数写入当前流，并将流的位置提升 4 个字节。
            </summary>
            <param name="value">要写入的 4 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.UInt64)">
            <summary>
            将 8 字节无符号整数写入当前流，并将流的位置提升 8 个字节。
            </summary>
            <param name="value">要写入的 8 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Single)">
            <summary>
            将 4 字节浮点值写入当前流，并将流的位置提升 4 个字节。
            </summary>
            <param name="value">要写入的 4 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Double)">
            <summary>
            将 8 字节浮点值写入当前流，并将流的位置提升 8 个字节。
            </summary>
            <param name="value">要写入的 8 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Char)">
            <summary>
            将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。
            </summary>
            <param name="ch">要写入的非代理项 Unicode 字符。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Char[])">
            <summary>
            将字符数组写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。
            </summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            将字符数组部分写入当前流，并根据所使用的 Encoding（可能还根据向流中写入的特定字符），提升流的当前位置。
            </summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
            <param name="index">chars 中开始写入的起始点。</param>
            <param name="count">要写入的字符数。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.String)">
            <summary>
            写入字符串
            </summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Boolean)">
            <summary>
            将单字节 Boolean 值写入
            </summary>
            <param name="value">要写入的 Boolean 值</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Decimal)">
            <summary>
            将一个十进制值写入当前流，并将流位置提升十六个字节。
            </summary>
            <param name="value">要写入的十进制值。</param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.DateTime)">
            <summary>
            将一个时间日期写入
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteValue(System.Object,System.Type)">
            <summary>
            写入值类型，只能识别基础类型，对于不能识别的类型，方法返回false
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Collections.IDictionary)">
            <summary>
            写入枚举类型数据
            </summary>
            <param name="value">枚举数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteDictionary(System.Collections.IDictionary,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入字典类型数据
            </summary>
            <param name="value">字典数据</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteKeyValue(System.Collections.DictionaryEntry,System.Type,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入字典项
            </summary>
            <param name="value">对象</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="index">成员索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteKeyValue(System.Collections.DictionaryEntry,System.Type,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入字典项
            </summary>
            <param name="value">对象</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="index">成员索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.GetDictionaryEntryType(System.Type,System.Type@,System.Type@)">
            <summary>
            取得字典的键值类型，默认只支持获取两个泛型参数的字典的键值类型
            </summary>
            <param name="type">字典类型</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <returns>是否获取成功，如果失败，则字典读取失败</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Collections.IEnumerable)">
            <summary>
            写入枚举类型数据
            </summary>
            <param name="value">枚举数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteEnumerable(System.Collections.IEnumerable,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入枚举数据，复杂类型使用委托方法进行处理
            </summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteItem(System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入枚举项
            </summary>
            <param name="value">对象</param>
            <param name="type">元素类型</param>
            <param name="index">元素索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteItem(System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入枚举项
            </summary>
            <param name="value">对象</param>
            <param name="type">元素类型</param>
            <param name="index">元素索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteSerializable(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入实现了可序列化接口的对象
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteUnKnown(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入未知对象（其它所有方法都无法识别的对象），采用BinaryFormatter或者XmlSerialization
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteX(System.Object,System.Type)">
            <summary>
            扩展写入，反射查找合适的写入方法
            </summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Guid)">
            <summary>
            写入Guid
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWrite(System.Guid)">
            <summary>
            写入Guid
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Net.IPAddress)">
            <summary>
            写入IPAddress
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWrite(System.Net.IPAddress)">
            <summary>
            写入IPAddress
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Net.IPEndPoint)">
            <summary>
            写入IPEndPoint
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWrite(System.Net.IPEndPoint)">
            <summary>
            写入IPEndPoint
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Write(System.Type)">
            <summary>
            写入Type
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWrite(System.Type)">
            <summary>
            写入Type
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteType(System.Type)">
            <summary>
            写入Type
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.IsExactType(System.Type)">
            <summary>
            获取精确类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.CheckAndWriteType(System.String,System.Object,System.Type)">
            <summary>
            检查对象类型与指定写入类型是否一致，若不一致，则先写入类型，以保证读取的时候能够以正确的类型读取。同时返回对象实际类型。
            </summary>
            <param name="action"></param>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteObjectType(System.Type)">
            <summary>
            写对象类型
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteObject(System.Object)">
            <summary>
            把对象写入数据流
            </summary>
            <param name="value">对象</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            把目标对象指定成员写入数据流，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            把目标对象指定成员写入数据流，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteRefObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入引用对象
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteObjRef(System.Object)">
            <summary>
            写入对象引用。
            </summary>
            <param name="value">对象</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteObjRefIndex(System.Int32)">
            <summary>
            写对象引用计数
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteCustomObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写对象成员
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteMember(System.Object,System.Type,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入成员
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.OnWriteMember(System.Object,System.Type,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入成员
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteSize(System.Int32)">
            <summary>
            写入大小
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.WriteLengths(System.String)">
            <summary>
            写入长度
            </summary>
            <param name="lengths"></param>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Flush">
            <summary>
            刷新缓存中的数据
            </summary>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.AutoFlush">
            <summary>
            如果设置了自动刷新缓存，该方面将会调用Flush
            </summary>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.Reset">
            <summary>
            重置
            </summary>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.ToArray">
            <summary>
            输出数据转为字节数组
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.WriterBase`1.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnObjectWriting">
            <summary>
            写对象前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnObjectWrited">
            <summary>
            写对象后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnMemberWriting">
            <summary>
            写成员前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnMemberWrited">
            <summary>
            写成员后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnDictionaryWriting">
            <summary>
            写字典项前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnDictionaryWrited">
            <summary>
            写字典项后触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnItemWriting">
            <summary>
            写枚举项前触发。
            </summary>
        </member>
        <member name="E:NewLife.Serialization.WriterBase`1.OnItemWrited">
            <summary>
            写枚举项后触发。
            </summary>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Byte)">
            <summary>
            将一个无符号字节写入
            </summary>
            <param name="value">要写入的无符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将字节数组部分写入当前流。
            </summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="index">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Int16)">
            <summary>
            将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。
            </summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Int32)">
            <summary>
            将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。
            </summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Int64)">
            <summary>
            将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。
            </summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Single)">
            <summary>
            将 4 字节浮点值写入当前流，并将流的位置提升 4 个字节。
            </summary>
            <param name="value">要写入的 4 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Double)">
            <summary>
            将 8 字节浮点值写入当前流，并将流的位置提升 8 个字节。
            </summary>
            <param name="value">要写入的 8 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            将字符数组部分写入当前流，并根据所使用的 Encoding（可能还根据向流中写入的特定字符），提升流的当前位置。
            </summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
            <param name="index">chars 中开始写入的起始点。</param>
            <param name="count">要写入的字符数。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.String)">
            <summary>
            写入字符串
            </summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Boolean)">
            <summary>
            将单字节 Boolean 值写入
            </summary>
            <param name="value">要写入的 Boolean 值</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.Decimal)">
            <summary>
            将一个十进制值写入当前流，并将流位置提升十六个字节。
            </summary>
            <param name="value">要写入的十进制值。</param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.Write(System.DateTime)">
            <summary>
            将一个时间日期写入
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.OnWrite(System.Guid)">
            <summary>
            写入Guid
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.OnWrite(System.Net.IPAddress)">
            <summary>
            写入IPAddress
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.OnWrite(System.Net.IPEndPoint)">
            <summary>
            写入IPEndPoint
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.TextWriterBase`1.WriteValue(System.Object,System.Type)">
            <summary>
            写入值类型，只能识别基础类型，对于不能识别的类型，方法返回false
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="P:NewLife.Serialization.TextWriterBase`1.UseSize">
            <summary>是否使用大小，如果使用，将在写入数组、集合和字符串前预先写入大小。字符串类型读写器一般带有边界，不需要使用大小</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Byte)">
            <summary>
            以数字的格式写入字节
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Byte[])">
            <summary>
            将字节数组以[0xff,0xff,0xff]的格式写入
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将字节数组部分写入当前流。
            </summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="index">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Boolean)">
            <summary>
            将单字节 Boolean 值写入
            </summary>
            <param name="value">要写入的 Boolean 值</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.DateTime)">
            <summary>
            将一个时间日期写入
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Int16)">
            <summary>
            将 2 字节有符号整数写入当前流
            </summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Int32)">
            <summary>
            将 4 字节有符号整数写入当前流
            </summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Int64)">
            <summary>
            将 8 字节有符号整数写入当前流
            </summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Single)">
            <summary>
            将 4 字节浮点值写入当前流
            </summary>
            <param name="value">要写入的 4 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Double)">
            <summary>
            将 8 字节浮点值写入当前流
            </summary>
            <param name="value">要写入的 8 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Decimal)">
            <summary>
            将一个十进制值写入当前流，并将流位置提升十六个字节。
            </summary>
            <param name="value">要写入的十进制值。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteLiteral(System.String)">
            <summary>
            输出字符串字面值,不做编码处理
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Char)">
            <summary>
            将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。
            </summary>
            <param name="ch">要写入的非代理项 Unicode 字符。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Char[])">
            <summary>
            将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。
            </summary>
            <param name="chars"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。
            </summary>
            <param name="chars"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.String)">
            <summary>
            写入字符串
            </summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.JavascriptStringEncode(System.String)">
            <summary>
            将指定字符串编码成json中表示的字符串,将编码Unicode字符为\uXXXX
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.JavascriptStringEncode(System.String,System.Boolean)">
            <summary>
            将指定字符串编码成javascript的字面字符串(即写入到js代码中的和value内容相同的代码),开始和结尾不包含双引号
            </summary>
            <param name="value">要编码的字符串,value为null时返回""</param>
            <param name="encodeUnicode">是否将Unicode字符编码为\uXXXX的格式</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteEnumerable(System.Collections.IEnumerable,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入枚举数据，复杂类型使用委托方法进行处理
            </summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.OnWriteItem(System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入枚举项
            </summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="index">成员索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Slice``1(``0[],System.Int32,System.Int32)">
            <summary>
            返回指定数组的一个片段,始终返回的是array参数的一个副本
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteDictionary(System.Collections.IDictionary,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            将字典类型数据写入到当前流位置
            </summary>
            <param name="value"></param>
            <param name="type"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.OnWriteKeyValue(System.Collections.DictionaryEntry,System.Type,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入字典键和值
            </summary>
            <param name="value"></param>
            <param name="keyType"></param>
            <param name="valueType"></param>
            <param name="index"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Serialization.JsonWriter.writeValueType">
            <summary>
            是否需要写入值类型信息的标志,为null时表示不需要,非null时并且等于待写入的值时写入值类型
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonWriter.ComplexObjectDepth">
            <summary>
            写入的复合对象深度,指使用{} []包括的深度
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonWriter.WriteMemberCount">
            <summary>
            是否写入成员的计数器,用于控制换行输出
            </summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteObjectType(System.Type)">
            <summary>
            JsonWriter的对象类型由writeValueType写入,作为第一个成员,所以不需要
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.OnWriteObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入对象。具体读写器可以重载该方法以修改写入对象前后的行为。
            </summary>
            <param name="value">对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.WriteCustomObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写对象成员
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.OnWriteMember(System.Object,System.Type,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入成员
            </summary>
            <param name="value">要写入的对象</param>
            <param name="memberType">要写入的成员类型</param>
            <param name="member">要写入的成员信息,可以通过[value]取得成员值</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.ComplexObjectDepthIsOverflow">
            <summary>
            当前解析复合对象深度是否超出,用于避免循环引用可能引起的堆栈溢出,仅在Settings.RepeatedActionType是RepeatedAction.DepthLimit时才可能返回true
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.IsCanCreateInstance(System.Type)">
            <summary>
            返回指定类型是否是可以实例化的,即反序列化时是否是可以实例化的类型,一般用于处理未知类型前
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.BaseWriteMember(NewLife.Serialization.IWriter,System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            模仿父类的WriteMember实现
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="type"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Flush">
            <summary>
            刷新缓存中的数据
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.Writer">
            <summary>写入器</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.Stream">
            <summary>
            数据流。更改数据流后，重置Writer为空，以使用新的数据流
            </summary>
        </member>
        <member name="T:NewLife.Security.Certificate">
            <summary>
            证书
            </summary>
            <remarks>http://blogs.msdn.com/b/dcook/archive/2008/11/25/creating-a-self-signed-certificate-in-c.aspx</remarks>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String)">
            <summary>
            建立自签名证书
            </summary>
            <param name="x500"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime)">
            <summary>
            建立自签名证书
            </summary>
            <param name="x500"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime,System.String)">
            <summary>
            建立自签名证书
            </summary>
            <param name="x500"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="insecurePassword"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime,System.Security.SecureString)">
            <summary>
            建立自签名证书
            </summary>
            <param name="x500">例如CN=SelfSignCertificate;C=China;OU=NewLife;O=Development Team;E=nnhy@vip.qq.com，其中CN是显示名</param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.Security.Cryptography.X509Certificates.X500DistinguishedName,System.DateTime,System.DateTime,System.Security.SecureString)">
            <summary>
            建立自签名证书
            </summary>
            <param name="distName"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.SingleListNode`1">
            <summary>
            单向链表节点
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.#ctor(`0)">
            <summary>
            使用一个对象初始化一个节点
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.#ctor(`0,NewLife.Collections.SingleListNode{`0})">
            <summary>
            使用一个对象和下一个节点初始化一个节点
            </summary>
            <param name="item"></param>
            <param name="next"></param>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.Contain(`0)">
            <summary>
            在单向链表中查找指定项
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.SingleListNode`1.Remove(`0)">
            <summary>
            在单向链表中移除指定项
            </summary>
            <param name="item">指定项</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.SingleListNode`1.Item">
            <summary>元素</summary>
        </member>
        <member name="P:NewLife.Collections.SingleListNode`1.Next">
            <summary>下一个节点</summary>
        </member>
        <member name="T:NewLife.Log.XTrace">
            <summary>
            日志类，包含跟踪调试功能
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String)">
            <summary>
            输出日志
            </summary>
            <param name="msg">信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.DebugStack">
            <summary>
            堆栈调试。
            输出堆栈信息，用于调试时处理调用上下文。
            本方法会造成大量日志，请慎用。
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.DebugStack(System.Int32)">
            <summary>
            堆栈调试。
            </summary>
            <param name="maxNum">最大捕获堆栈方法数</param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String,System.Object[])">
            <summary>
            写日志
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="P:NewLife.Log.XTrace.LogPath">
            <summary>
            日志路径
            </summary>
        </member>
        <member name="E:NewLife.Log.XTrace.OnWriteLog">
            <summary>
            写日志事件。绑定该事件后，XTrace将不再把日志写到日志文件中去。
            </summary>
        </member>
        <member name="P:NewLife.Log.XTrace.Debug">
            <summary>是否调试。如果代码指定了值，则只会使用代码指定的值，否则每次都读取配置。</summary>
        </member>
        <member name="T:NewLife.Threading.ThreadTask">
            <summary>
            线程任务
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadTask.#ctor(System.Threading.WaitCallback,System.Object)">
            <summary>
            构造一个线程任务
            </summary>
            <param name="method">任务方法</param>
            <param name="argument">任务参数</param>
        </member>
        <member name="M:NewLife.Threading.ThreadTask.#ctor(System.Threading.WaitCallback,System.Threading.WaitCallback,System.Object)">
            <summary>
            构造一个线程任务
            </summary>
            <param name="method">任务方法</param>
            <param name="abortMethod">任务被取消时执行的方法</param>
            <param name="argument">任务参数</param>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.ID">
            <summary>唯一编号</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.Method">
            <summary>任务方法</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.Argument">
            <summary>任务参数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.AbortMethod">
            <summary>取消任务时执行的方法</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadTask.newID">
            <summary>
            取一个新编号
            </summary>
        </member>
        <member name="T:NewLife.Serialization.RWServices">
            <summary>
            读写服务
            </summary>
        </member>
        <member name="T:NewLife.Serialization.ObjectInfo">
            <summary>
            对象信息
            </summary>
        </member>
        <member name="F:NewLife.Serialization.ObjectInfo.DefaultStreamingContext">
            <summary>默认上下文</summary>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.CreateObjectMemberInfo(System.Reflection.MemberInfo)">
            <summary>
            创建反射成员信息
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.CreateObjectMemberInfo(System.String,System.Type,System.Object)">
            <summary>
            创建简单成员信息
            </summary>
            <param name="name"></param>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.GetMembers(System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>
            获取指定对象的成员信息。优先考虑ISerializable接口。
            对于Write，该方法没有任何，问题；对于Read，如果是ISerializable接口，并且value是空，则可能无法取得成员信息。
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="isField">是否字段</param>
            <param name="isBaseFirst">是否基类成员排在前面</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.FindFields(System.Type,System.Boolean)">
            <summary>
            取得所有字段
            </summary>
            <param name="type"></param>
            <param name="isBaseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.FindProperties(System.Type,System.Boolean)">
            <summary>
            取得所有属性
            </summary>
            <param name="type"></param>
            <param name="isBaseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.ObjectInfo.GetDefaultObject(System.Type)">
            <summary>
            获取某个类型的默认对象
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.IServer">
            <summary>
            服务接口。
            </summary>
            <remarks>服务代理XAgent可以附加代理实现了IServer接口的服务。</remarks>
        </member>
        <member name="M:NewLife.Model.IServer.Start">
            <summary>
            开始
            </summary>
        </member>
        <member name="M:NewLife.Model.IServer.Stop">
            <summary>
            停止
            </summary>
        </member>
        <member name="T:NewLife.WeakEventHandler`1">
            <summary>
            弱引用事件
            </summary>
            <remarks>
            很多绑定事件的场合，并不适合取消绑定，这就造成了事件资源无法得到回收。
            更加麻烦的是，事件本身除了包含事件处理方法外，还会包含目标对象，也就导致目标对象无法得到释放。
            弱引用事件的原理是把目标对象与事件处理方法分拆开来，使用弱引用来引用目标对象，保证目标对象能够得到有效的释放。
            触发弱引用事件时，首先判断目标对象是否可用，因为其可能已经被GC回收，然后再通过快速访问方法调用事件处理方法。
            也许有人会问，如果目标对象不可用怎么办？岂不是无法执行事件处理方法了？
            我们换一个角度来看，既然目标对象都已经不存在了，它绑定的事件自然也就无需过问了！
            </remarks>
            <typeparam name="TEventArgs"></typeparam>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Target">
            <summary>
            目标对象。弱引用，使得调用方对象可以被GC回收
            </summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Method">
            <summary>
            委托方法
            </summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Handler">
            <summary>
            经过包装的新的委托
            </summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.UnHandler">
            <summary>
            取消注册的委托
            </summary>
        </member>
        <member name="F:NewLife.WeakEventHandler`1.Once">
            <summary>
            是否只使用一次，如果只使用一次，执行委托后马上取消注册
            </summary>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.#ctor(System.EventHandler{`0},System.Action{System.EventHandler{`0}},System.Boolean)">
            <summary>
            使用事件处理器、取消注册回调、是否一次性事件来初始化
            </summary>
            <param name="handler"></param>
            <param name="unHandler"></param>
            <param name="once"></param>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.Invoke(System.Object,`0)">
            <summary>
            调用委托
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.op_Implicit(NewLife.WeakEventHandler{`0})~System.EventHandler{`0}">
            <summary>
            把弱引用事件处理器转换为普通事件处理器
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.Combine(System.EventHandler{`0}@)">
            <summary>
            绑定
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.WeakEventHandler`1.Remove(System.EventHandler{`0}@,System.EventHandler{`0})">
            <summary>
            移除
            </summary>
            <param name="handler"></param>
            <param name="value"></param>
        </member>
        <member name="T:NewLife.Collections.ListBase`1">
            <summary>
            泛型列表基类。主要提供一个重载实现自定义列表的基类实现。
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.Add(`0)">
            <summary>
            添加
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.Clear">
            <summary>
            清空
            </summary>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.Contains(`0)">
            <summary>
            是否包含指定元素
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            把元素复制到一个数组里面
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.GetEnumerator">
            <summary>
            获取一个枚举器
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.IndexOf(`0)">
            <summary>
            确定列表中特定项的索引。
            </summary>
            <param name="value">要在列表中定位的对象。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.Insert(System.Int32,`0)">
            <summary>
            将一个项插入指定索引处的列表。
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.Remove(`0)">
            <summary>
            从列表中移除指定对象
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.RemoveAt(System.Int32)">
            <summary>
            移除指定索引处的列表项。
            </summary>
            <param name="index"></param>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.InnerList">
            <summary>内部列表</summary>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.Count">
            <summary>
            列表元素个数
            </summary>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.IsFixedSize">
            <summary>
            是否固定大小
            </summary>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.IsReadOnly">
            <summary>
            是否只读
            </summary>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.Item(System.Int32)">
            <summary>
            获取或设置指定索引处的元素。
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.ListBase`1.IListEnumerator`1">
            <summary>
            泛型列表枚举器
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.IListEnumerator`1.#ctor(System.Collections.Generic.IList{`1})">
            <summary>
            使用泛型列表实例化一个枚举器
            </summary>
            <param name="sequence"></param>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.IListEnumerator`1.Dispose">
            <summary>
            销毁
            </summary>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.IListEnumerator`1.MoveNext">
            <summary>
            将枚举数推进到集合的下一个元素。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListBase`1.IListEnumerator`1.System#Collections#IEnumerator#Reset">
            <summary>
            将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。
            </summary>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.IListEnumerator`1.Current">
            <summary>
            获取集合中的当前元素。
            </summary>
        </member>
        <member name="P:NewLife.Collections.ListBase`1.IListEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            获取集合中的当前元素。
            </summary>
        </member>
        <member name="T:NewLife.Xml.XmlEntity`1">
            <summary>
            XML实体基类
            <remarks>主要提供数据实体和XML文件之间的映射功能</remarks>
            </summary>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.Load(System.String)">
            <summary>
            从一段XML文本中加载对象
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.LoadFile(System.String)">
            <summary>
            从一个XML文件中加载对象
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.ToXml">
            <summary>
            输出XML
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.ToXml(System.String,System.String)">
            <summary>
            输出Xml
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.ToInnerXml">
            <summary>
            输出内部XML
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlEntity`1.Save(System.String)">
            <summary>
            保存到文件中
            </summary>
            <param name="filename"></param>
        </member>
        <member name="T:NewLife.Common.IdentityCard">
            <summary>
            身份证
            </summary>
        </member>
        <member name="M:NewLife.Common.IdentityCard.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Common.IdentityCard.Valid(System.String)">
            <summary>
            验证身份证是否合法
            </summary>
            <param name="card"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.IdentityCard.Parse(System.String)">
            <summary>
            使用身份证号码初始化
            </summary>
            <param name="card"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Common.IdentityCard.Birthday">
            <summary>生日</summary>
        </member>
        <member name="P:NewLife.Common.IdentityCard.Sex">
            <summary>性别</summary>
        </member>
        <member name="P:NewLife.Common.IdentityCard.IsOld">
            <summary>是否15位旧卡</summary>
        </member>
        <member name="P:NewLife.Common.IdentityCard.AreaNum">
            <summary>地区编码</summary>
        </member>
        <member name="T:NewLife.Common.IdentityCard.SexType">
            <summary>
            性别
            </summary>
        </member>
        <member name="F:NewLife.Common.IdentityCard.SexType.Man">
            <summary>
            男
            </summary>
        </member>
        <member name="F:NewLife.Common.IdentityCard.SexType.Woman">
            <summary>
            女
            </summary>
        </member>
        <member name="T:NewLife.Log.CodeTimer">
            <summary>
            代码性能计时器
            </summary>
            <remarks>参考了老赵（http://www.cnblogs.com/jeffreyzhao/archive/2009/03/10/codetimer.html）和eaglet（http://www.cnblogs.com/eaglet/archive/2009/03/10/1407791.html）两位的作品</remarks>
            <remarks>为了保证性能比较的公平性，采用了多种指标，并使用计时器重写等手段来避免各种不必要的损耗</remarks>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time(System.Int32,System.Action{System.Int32})">
            <summary>
            计时
            </summary>
            <param name="times"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeLine(System.String,System.Int32,System.Action{System.Int32})">
            <summary>
            计时，并用控制台输出行
            </summary>
            <param name="title"></param>
            <param name="times"></param>
            <param name="action"></param>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time">
            <summary>
            计时核心方法，处理进程和线程优先级
            </summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeTrue">
            <summary>
            真正的计时
            </summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeOne">
            <summary>
            执行一次迭代，预热所有方法
            </summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Init">
            <summary>
            迭代前执行，计算时间
            </summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time(System.Int32)">
            <summary>
            每一次迭代，计算时间
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Finish">
            <summary>
            迭代后执行，计算时间
            </summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.ToString">
            <summary>
            已重载。输出依次分别是：执行时间、CPU线程时间、时钟周期、GC代数
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Times">
            <summary>次数</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Action">
            <summary>迭代方法，如不指定，则使用Time(int index)</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.ShowProgress">
            <summary>是否显示控制台进度</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Index">
            <summary>进度</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.CpuCycles">
            <summary>CPU周期</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.ThreadTime">
            <summary>线程时间，单位是100ns，除以10000转为ms</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Gen">
            <summary>GC代数</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Elapsed">
            <summary>执行时间</summary>
        </member>
        <member name="T:NewLife.IO.StreamClient">
            <summary>
            数据流客户端，用于与服务端的数据流处理器通讯
            </summary>
        </member>
        <member name="M:NewLife.IO.StreamClient.#ctor">
            <summary>
            实例化
            </summary>
        </member>
        <member name="M:NewLife.IO.StreamClient.#ctor(System.Uri)">
            <summary>
            实例化
            </summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.IO.StreamClient.#ctor(System.String)">
            <summary>
            实例化
            </summary>
            <param name="url"></param>
        </member>
        <member name="M:NewLife.IO.StreamClient.Send(System.Byte[])">
            <summary>
            同步发送数据
            </summary>
            <param name="data">待发送数据</param>
            <returns>服务端响应数据</returns>
        </member>
        <member name="M:NewLife.IO.StreamClient.SendAsync(System.Byte[])">
            <summary>
            异步发送数据，服务端响应数据将由数据流总线处理
            </summary>
            <param name="data">待发送数据</param>
        </member>
        <member name="M:NewLife.IO.StreamClient.Process(System.IO.Stream)">
            <summary>
            处理数据流
            </summary>
            <param name="stream"></param>
        </member>
        <member name="F:NewLife.IO.StreamClient._Stream">
            <summary>内部数据流</summary>
        </member>
        <member name="M:NewLife.IO.StreamClient.GetStream">
            <summary>
            获取用于收发数据的数据流
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.IO.StreamClient.Uri">
            <summary>服务端地址</summary>
        </member>
        <member name="P:NewLife.IO.StreamClient.StreamHandlerName">
            <summary>数据流总线名称</summary>
        </member>
        <member name="T:NewLife.IO.StreamClient.InternalStream">
            <summary>
            内部数据流。重写输入行为，然后使用一个内存流作为输出。
            </summary>
        </member>
        <member name="T:NewLife.IO.ReadWriteStream">
            <summary>
            读写流。内部包含输入流和输出流两个流，实际读取从输入流读取，写入则写入到输出流
            </summary>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>
            初始化
            </summary>
            <param name="inputStream"></param>
            <param name="outputStream"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Flush">
            <summary>
            刷新输出流写入的数据
            </summary>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从输入流中读取数据
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            在输入流中搜索
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.SetLength(System.Int64)">
            <summary>
            设置输出流的长度
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            把数据写入到输出流中
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            开始异步读操作
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.EndRead(System.IAsyncResult)">
            <summary>
            等待挂起的异步读完成
            </summary>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            开始异步写操作
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.EndWrite(System.IAsyncResult)">
            <summary>
            等待挂起的异步写完成
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.Peek">
            <summary>
            读取一个字节，不移动指针
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteStream.CheckArgument(System.Byte[],System.Int32,System.Int32)">
            <summary>
            检查参数
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.InputStream">
            <summary>输入流</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.OutputStream">
            <summary>输出流</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.CanRead">
            <summary>
            输入流是否可读
            </summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.CanSeek">
            <summary>
            输入流是否可移动
            </summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.CanWrite">
            <summary>
            输出流是否可写
            </summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.Length">
            <summary>
            输入流总长度
            </summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteStream.Position">
            <summary>
            输入流位置
            </summary>
        </member>
        <member name="P:NewLife.IO.StreamClient.InternalStream.Client">
            <summary>数据流客户端</summary>
        </member>
        <member name="T:NewLife.Collections.InterlockedStack`1">
            <summary>
            先进先出LIFO的原子锁栈结构，采用CAS保证线程安全。
            </summary>
            <remarks>
            经过测试，对象数量在万级以上时，性能急剧下降！
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:NewLife.Collections.InterlockedStack`1.Top">
            <summary>
            栈顶
            </summary>
        </member>
        <member name="F:NewLife.Collections.InterlockedStack`1._version">
            <summary>
            版本
            </summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Push(`0)">
            <summary>
            向栈压入一个对象
            </summary>
            <remarks>重点解决多线程环境下资源争夺以及使用lock造成性能损失的问题</remarks>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Pop">
            <summary>
            从栈中弹出一个对象
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.TryPop(`0@)">
            <summary>
            尝试从栈中弹出一个对象
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Peek">
            <summary>
            获取栈顶对象，不弹栈
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.TryPeek(`0@)">
            <summary>
            尝试获取栈顶对象，不弹栈
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Clear">
            <summary>
            清空
            </summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.ToArray">
            <summary>
            转为数组
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.GetEnumerator">
            <summary>
            获取枚举器
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.InterlockedStack`1.Count">
            <summary>元素个数</summary>
        </member>
        <member name="T:NewLife.Collections.InterlockedStack`1.Enumerator">
            <summary>
            原子栈枚举器
            </summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Enumerator.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="M:NewLife.Collections.InterlockedStack`1.Enumerator.MoveNext">
            <summary>
            移到下一个
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.InterlockedStack`1.Enumerator.Current">
            <summary>
            当前对象
            </summary>
        </member>
        <member name="T:NewLife.Collections.ObjectPool`1">
            <summary>
            对象池
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Push(`0)">
            <summary>
            归还
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Pop">
            <summary>
            借出
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Create">
            <summary>
            创建实例
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Clear">
            <summary>
            清空
            </summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnDispose(System.Boolean)">
            <summary>
            子类重载实现资源释放逻辑
            </summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Stock">
            <summary>在库</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.StockCount">
            <summary>在库</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.NotStockCount">
            <summary>不在库</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.CreateCount">
            <summary>创建数</summary>
        </member>
        <member name="T:NewLife.WeakReference`1">
            <summary>
            弱引用
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.WeakReference`1.#ctor">
            <summary>
            实例化
            </summary>
        </member>
        <member name="M:NewLife.WeakReference`1.#ctor(`0)">
            <summary>
            实例化
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:NewLife.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>
            实例化
            </summary>
            <param name="target"></param>
            <param name="trackResurrection"></param>
        </member>
        <member name="M:NewLife.WeakReference`1.op_Implicit(NewLife.WeakReference{`0})~`0">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakReference`1.op_Implicit(`0)~NewLife.WeakReference{`0}">
            <summary>
            类型转换
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.WeakReference`1.Target">
            <summary>
            目标引用对象
            </summary>
        </member>
        <member name="T:NewLife.IO.HttpStreamClient">
            <summary>
            基于Http协议的数据流客户端
            </summary>
        </member>
        <member name="M:NewLife.IO.HttpStreamClient.#ctor">
            <summary>
            实例化
            </summary>
        </member>
        <member name="M:NewLife.IO.HttpStreamClient.#ctor(System.Uri)">
            <summary>
            实例化
            </summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.IO.HttpStreamClient.#ctor(System.String)">
            <summary>
            实例化
            </summary>
            <param name="url"></param>
        </member>
        <member name="M:NewLife.IO.HttpStreamClient.Send(System.Byte[])">
            <summary>
            同步发送数据
            </summary>
            <param name="data">待发送数据</param>
            <returns>服务端响应数据</returns>
        </member>
        <member name="M:NewLife.IO.HttpStreamClient.SendAsync(System.Byte[])">
            <summary>
            异步发送数据，服务端响应数据将由数据流总线处理
            </summary>
            <param name="data">待发送数据</param>
        </member>
        <member name="P:NewLife.IO.HttpStreamClient.Client">
            <summary>客户端</summary>
        </member>
        <member name="T:NewLife.Reflection.DuckTyping">
            <summary>
            鸭子类型。用于解决编写插件时必须实现插件接口的问题。使用适配器模式，动态生成代理类。
            </summary>
        </member>
        <member name="M:NewLife.Reflection.DuckTyping.Implement``1(System.Object[])">
            <summary>
            转换多个对象
            </summary>
            <typeparam name="TInterface"></typeparam>
            <param name="objects"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DuckTyping.Implement``1(System.Object)">
            <summary>
            转换单个对象
            </summary>
            <typeparam name="TInterface"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DuckTyping.Implement(System.Object,System.Type)">
            <summary>
            转换单个对象
            </summary>
            <param name="obj"></param>
            <param name="interfaceType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DuckTyping.PrepareDuckTypes``1(System.Type[])">
            <summary>
            准备鸭子类型
            </summary>
            <typeparam name="TInterface"></typeparam>
            <param name="duckedTypes"></param>
        </member>
        <member name="M:NewLife.Reflection.DuckTyping.CreateDuckTypes(System.Type,System.Type[])">
            <summary>
            Core-Creation of the DuckTypes. It asumes that all arguments are validated before the method is called.
            </summary>
            <param name="interfaceType"></param>
            <param name="duckedTypes">a distinct list of Types to create the Duck-Types</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.TypeResolutionService">
            <summary>
            按名称检索程序集或类型
            </summary>
        </member>
        <member name="M:NewLife.Model.TypeResolutionService.#ctor">
            <summary>
            实例化
            </summary>
        </member>
        <member name="M:NewLife.Model.TypeResolutionService.#ctor(System.IServiceProvider,System.ComponentModel.Design.ITypeResolutionService)">
            <summary>
            实例化
            </summary>
            <param name="provider"></param>
            <param name="baseservice"></param>
        </member>
        <member name="M:NewLife.Model.TypeResolutionService.GetAssembly(System.Reflection.AssemblyName,System.Boolean)">
            <summary>
            获取请求的程序集
            </summary>
            <param name="name"></param>
            <param name="throwOnError"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.TypeResolutionService.GetAssembly(System.Reflection.AssemblyName)">
            <summary>
            获取请求的程序集
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.TypeResolutionService.GetPathOfAssembly(System.Reflection.AssemblyName)">
            <summary>
            获取从中加载程序集的文件的路径
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.TypeResolutionService.GetType(System.String,System.Boolean,System.Boolean)">
            <summary>
            用指定的名称加载类型
            </summary>
            <param name="name"></param>
            <param name="throwOnError"></param>
            <param name="ignoreCase"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.TypeResolutionService.GetType(System.String,System.Boolean)">
            <summary>
            用指定的名称加载类型
            </summary>
            <param name="name"></param>
            <param name="throwOnError"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.TypeResolutionService.GetType(System.String)">
            <summary>
            用指定的名称加载类型
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.TypeResolutionService.ReferenceAssembly(System.Reflection.AssemblyName)">
            <summary>
            将引用添加到指定程序集中
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:NewLife.Web.HttpState`1">
            <summary>
            Http状态，经常用于登录用户的Current
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:NewLife.Web.HttpState`1.EntityToCookie">
            <summary>
            实体转为Cookie的方法
            </summary>
        </member>
        <member name="F:NewLife.Web.HttpState`1.CookieToEntity">
            <summary>
            Cookie转为实体的方法
            </summary>
        </member>
        <member name="F:NewLife.Web.HttpState`1.Save">
            <summary>
            自定义保存
            </summary>
        </member>
        <member name="F:NewLife.Web.HttpState`1.Load">
            <summary>
            自定义加载
            </summary>
        </member>
        <member name="M:NewLife.Web.HttpState`1.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Web.HttpState`1.#ctor(System.String)">
            <summary>
            初始化
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Web.HttpState`1.Get(System.Converter{System.Web.HttpCookie,`0})">
            <summary>
            获取Http状态
            </summary>
            <param name="conv">把Cookie转为实体的转换器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.HttpState`1.Get(System.Converter{System.Web.HttpCookie,`0},System.Converter{NewLife.Web.HttpState{`0},`0})">
            <summary>
            获取Http状态
            </summary>
            <param name="conv">把Cookie转为实体的转换器</param>
            <param name="load">自定义加载方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.HttpState`1.Set(`0,System.Converter{`0,System.Web.HttpCookie})">
            <summary>
            设置Http状态
            </summary>
            <param name="entity"></param>
            <param name="conv">把实体转换为Cookie的转换器</param>
        </member>
        <member name="M:NewLife.Web.HttpState`1.Set(`0,System.Converter{`0,System.Web.HttpCookie},System.Converter{`0,System.Boolean})">
            <summary>
            设置Http状态
            </summary>
            <param name="entity">实体</param>
            <param name="conv">把实体转换为Cookie的转换器</param>
            <param name="save">自定义保存</param>
        </member>
        <member name="M:NewLife.Web.HttpState`1.GetCache(System.String)">
            <summary>
            从全局Cache中获取数据
            </summary>
            <param name="sessionID">使用SessionID作为数据在全局Cache中的标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.HttpState`1.SetCache(System.String,`0)">
            <summary>
            设置数据到全局Cache
            </summary>
            <param name="sessionID">使用SessionID作为数据在全局Cache中的标识</param>
            <param name="entity"></param>
        </member>
        <member name="P:NewLife.Web.HttpState`1.Key">
            <summary>键值</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.EnableSession">
            <summary>使用Session</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.EnableHttpItems">
            <summary>使用HttpItems</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.EnableCache">
            <summary>使用Cache</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.EnableCookie">
            <summary>使用Cookie</summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.Http">
            <summary>
            Http上下文
            </summary>
        </member>
        <member name="P:NewLife.Web.HttpState`1.Current">
            <summary>
            获取当前Http状态保存的对象
            </summary>
        </member>
        <member name="T:NewLife.IO.BinaryWriterX">
            <summary>
            二进制协议写入器
            </summary>
            <remarks>在二进制协议里面，需要定义每一种类型的序列化方式，本写入器仅处理通用的基本类型</remarks>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.#ctor(System.IO.Stream)">
            <summary>
            实例化
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            实例化
            </summary>
            <param name="stream"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteEncoded(System.Int16)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value"></param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteEncoded(System.Int32)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value"></param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteEncoded(System.Int64)">
            <summary>
            以7位压缩格式写入64位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value"></param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.Support(System.Type)">
            <summary>
            是否支持指定类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteObject(System.Object)">
            <summary>
            把对象写入数据流，空对象写入0，所有子孙成员编码整数、允许空、写入字段。
            </summary>
            <param name="value">对象</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteObject(System.Object,NewLife.Reflection.MemberInfoX,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            把目标对象指定成员写入数据流，通过委托方法递归处理成员
            </summary>
            <param name="target">对象</param>
            <param name="member">成员</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteObject(System.Object,NewLife.Reflection.MemberInfoX,System.Boolean,System.Boolean,System.Boolean,NewLife.IO.BinaryWriterX.WriteCallback)">
            <summary>
            把目标对象指定成员写入数据流，处理基础类型、特殊类型、基础类型数组、特殊类型数组，通过委托方法处理成员
            </summary>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteValue(System.Object,System.Boolean)">
            <summary>
            写入值类型，只能识别基础类型，对于不能识别的类型，方法返回false
            </summary>
            <param name="value">要写入的对象</param>
            <param name="encodeInt">是否编码整数</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteValue(System.Object,System.Type,System.Boolean)">
            <summary>
            写入值类型，只能识别基础类型，对于不能识别的类型，方法返回false
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="encodeInt">是否编码整数</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteStruct(System.ValueType)">
            <summary>
            写入结构体
            </summary>
            <param name="value"></param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteEnumerable(System.Collections.IEnumerable,System.Type,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            写入枚举数据，只处理元素类型是基本类型的数据
            </summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteEnumerable(System.Collections.IEnumerable,System.Type,System.Boolean,System.Boolean,System.Boolean,NewLife.IO.BinaryWriterX.WriteCallback)">
            <summary>
            写入枚举数据，复杂类型使用委托方法进行处理
            </summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteX(System.Object)">
            <summary>
            扩展写入，反射查找合适的写入方法
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.WriteX(System.Object,System.Type)">
            <summary>
            扩展写入，反射查找合适的写入方法
            </summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.Write(System.Guid)">
            <summary>
            写入Guid
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.Write(System.Net.IPAddress)">
            <summary>
            写入IPAddress
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.Write(System.Net.IPEndPoint)">
            <summary>
            写入IPEndPoint
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.Write(System.Type)">
            <summary>
            写入Type
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.FindFields(System.Type)">
            <summary>
            取得所有可序列化字段
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.BinaryWriterX.FindProperties(System.Type)">
            <summary>
            取得所有属性
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.IO.BinaryWriterX.Encoding">
            <summary>编码</summary>
        </member>
        <member name="T:NewLife.IO.BinaryWriterX.WriteCallback">
            <summary>
            数据写入方法
            </summary>
            <param name="writer">写入器</param>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="encodeInt">是否编码整数</param>
            <param name="allowNull">是否允许空</param>
            <param name="isProperty">是否处理属性</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="T:NewLife.EventArgs`1">
            <summary>
            泛型事件参数
            </summary>
            <typeparam name="TArg"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`1.#ctor(`0)">
            <summary>
            使用参数初始化
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:NewLife.EventArgs`1.Pop(`0@)">
            <summary>
            弹出
            </summary>
            <param name="arg"></param>
        </member>
        <member name="P:NewLife.EventArgs`1.Arg">
            <summary>参数</summary>
        </member>
        <member name="T:NewLife.EventArgs`2">
            <summary>
            泛型事件参数
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`2.#ctor(`0,`1)">
            <summary>
            使用参数初始化
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:NewLife.EventArgs`2.Pop(`0@,`1@)">
            <summary>
            弹出
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="T:NewLife.EventArgs`3">
            <summary>
            泛型事件参数
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`3.#ctor(`0,`1,`2)">
            <summary>
            使用参数初始化
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:NewLife.EventArgs`3.Pop(`0@,`1@,`2@)">
            <summary>
            弹出
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="T:NewLife.EventArgs`4">
            <summary>
            泛型事件参数
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
        </member>
        <member name="M:NewLife.EventArgs`4.#ctor(`0,`1,`2,`3)">
            <summary>
            使用参数初始化
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="M:NewLife.EventArgs`4.Pop(`0@,`1@,`2@,`3@)">
            <summary>
            弹出
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg4">
            <summary>参数4</summary>
        </member>
        <member name="T:NewLife.Threading.ReadWriteLock">
            <summary>
            原子读写锁
            </summary>
            <remark>
            任意多个读操作，只有一个写操作；
            任意读操作阻塞写操作，同样任意写操作阻塞非本线程读操作和其它写操作；
            </remark>
            <remarks>
            do...while(Interlocked.CompareExchange(ref _lock, oldLock - 1, oldLock) != oldLock)形式的原子锁结构，
            精髓在于do...while之间，里面才是真正的判断数据有效性核心，而CompareExchange仅仅是负责完成替换而已。
            实际上，就类似于准备好各种资料等上级审批，而上级每次只能审批一个，如果这次别人抢到了，那么自己得再次准备资料。
            </remarks>
        </member>
        <member name="F:NewLife.Threading.ReadWriteLock._lock">
            <summary>
            锁计数
            </summary>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.Create(System.Object)">
            <summary>
            根据指定键值创建读写锁，一般读写锁需要针对指定资源唯一
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.AcquireRead">
            <summary>
            请求读取锁
            </summary>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.AcquireRead(System.Int32)">
            <summary>
            请求读取锁，等待指定秒
            </summary>
            <param name="millisecondsTimeout"></param>
            <returns>是否取得锁</returns>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.ReleaseRead">
            <summary>
            释放读取锁
            </summary>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.AcquireWrite">
            <summary>
            请求写入锁
            </summary>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.AcquireWrite(System.Int32)">
            <summary>
            请求写入锁，等待指定秒
            </summary>
            <param name="millisecondsTimeout"></param>
            <returns>是否取得锁</returns>
        </member>
        <member name="M:NewLife.Threading.ReadWriteLock.ReleaseWrite">
            <summary>
            释放写入锁
            </summary>
        </member>
        <member name="P:NewLife.Threading.ReadWriteLock.Max">
            <summary>最大可独占资源数，默认1</summary>
        </member>
        <member name="P:NewLife.Threading.ReadWriteLock.ReadTimeout">
            <summary>读取锁等待超时时间，默认1秒</summary>
        </member>
        <member name="P:NewLife.Threading.ReadWriteLock.WriteTimeout">
            <summary>写入锁等待超时时间，默认5秒</summary>
        </member>
        <member name="T:NewLife.Serialization.WriteObjectEventArgs">
            <summary>
            写入对象事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.WriteObjectEventArgs.#ctor(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="value">对象</param>
            <param name="type">对象类型</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.WriteObjectEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.WriteObjectEventArgs.Type">
            <summary>对象类型</summary>
        </member>
        <member name="T:NewLife.Model.TypeDiscoveryService">
            <summary>
            发现可用类型
            </summary>
        </member>
        <member name="M:NewLife.Model.TypeDiscoveryService.#ctor">
            <summary>
            实例化
            </summary>
        </member>
        <member name="M:NewLife.Model.TypeDiscoveryService.#ctor(System.IServiceProvider,System.ComponentModel.Design.ITypeDiscoveryService)">
            <summary>
            实例化
            </summary>
            <param name="provider"></param>
            <param name="baseservice"></param>
        </member>
        <member name="M:NewLife.Model.TypeDiscoveryService.GetReferencedTypes(System.Type,System.Boolean)">
            <summary>
            检索可用类型的列表
            </summary>
            <param name="baseType">要匹配的基类型</param>
            <param name="excludeGlobalTypes">指示是否应检查来自所有引用程序集的类型</param>
            <returns>与 baseType 和 excludeGlobalTypes 指定的条件相匹配的类型的集合</returns>
        </member>
        <member name="M:NewLife.Model.TypeDiscoveryService.System#ComponentModel#Design#ITypeDiscoveryService#GetTypes(System.Type,System.Boolean)">
            <summary>
            检索可用类型的列表
            </summary>
            <param name="baseType">要匹配的基类型</param>
            <param name="excludeGlobalTypes">指示是否应检查来自所有引用程序集的类型</param>
            <returns>与 baseType 和 excludeGlobalTypes 指定的条件相匹配的类型的集合</returns>
        </member>
        <member name="T:NewLife.Threading.ThreadPoolX">
            <summary>
            线程池。所有静态方法和实例方法均是线程安全。
            </summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX.SynLock_mt">
            <summary>
            用于维护管理线程的锁
            </summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX._ManagerThread">
            <summary>
            使用volatile关键字，等到对象创建完成
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Init">
            <summary>
            第一个任务到来时初始化线程池
            </summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX.SyncLock_Threads">
            <summary>
            用户维护线程组的锁
            </summary>
        </member>
        <member name="F:NewLife.Threading.ThreadPoolX.Sync_Tasks">
            <summary>
            任务队列同步锁
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.#ctor(System.String)">
            <summary>
            构造一个线程池
            </summary>
            <param name="name">线程池名</param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Create(System.String)">
            <summary>
            创建线程池。一个名字只能创建一个线程池。线程安全。
            </summary>
            <param name="name">线程池名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(System.Threading.WaitCallback)">
            <summary>
            把用户工作项放入队列
            </summary>
            <param name="method">任务方法</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(System.Threading.WaitCallback,System.Object)">
            <summary>
            把用户工作项放入队列
            </summary>
            <param name="method">任务方法</param>
            <param name="argument">任务参数</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(System.Threading.WaitCallback,System.Threading.WaitCallback,System.Object)">
            <summary>
            把用户工作项放入队列。指定任务被取消时执行的方法，该方法仅针对尚未被线程开始调用时的任务有效
            </summary>
            <param name="method">任务方法</param>
            <param name="abortMethod">任务被取消时执行的方法</param>
            <param name="argument">任务参数</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Queue(NewLife.Threading.ThreadTask)">
            <summary>
            把用户工作项放入队列
            </summary>
            <param name="task">任务</param>
            <returns>任务编号</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Abort(System.Int32)">
            <summary>
            取消任务
            </summary>
            <param name="id">任务编号</param>
            <returns>任务状态</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AbortAllTask">
            <summary>
            取消所有未开始任务
            </summary>
            <remarks>这里不要调用上面Abort取消单个任务，否则可能会造成死锁</remarks>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AbortAllThread">
            <summary>
            取消所有进行中任务
            </summary>
            <remarks>这里不要调用上面Abort取消单个任务，否则可能会造成死锁</remarks>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AbortAll">
            <summary>
            取消所有任务
            </summary>
            <remarks>这里不要调用上面Abort取消单个任务，否则可能会造成死锁</remarks>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Query(System.Int32)">
            <summary>
            查询任务状态
            </summary>
            <param name="id">任务编号</param>
            <returns>任务状态</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueryCount">
            <summary>
            查询任务个数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.WaitAll(System.Int32)">
            <summary>
            等待所有任务完成，并指定是否在等待之前退出同步域。
            </summary>
            <param name="millisecondsTimeout"></param>
            <returns>是否在等待之前退出同步域</returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Work">
            <summary>
            调度包装
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.AddThread">
            <summary>
            添加线程。本方法不是线程安全，调用者需要自己维护线程安全
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Open">
            <summary>
            借用线程
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Close(NewLife.Threading.ThreadX)">
            <summary>
            归还线程
            </summary>
            <param name="thread"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Finalize">
            <summary>
            析构
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.MaxThreads">
            <summary>最大线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.MinThreads">
            <summary>最小线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Name">
            <summary>线程池名称</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.LastError">
            <summary>最后的异常</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.ManagerThread">
            <summary>维护线程</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Threads">
            <summary>线程组。适用该资源时，记得加上线程锁lockObj</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.ThreadCount">
            <summary>当前线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.RunningCount">
            <summary>正在处理任务的线程数</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Event">
            <summary>事件量</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Tasks">
            <summary>任务队列</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Debug">
            <summary>
            是否调试
            </summary>
        </member>
        <member name="T:NewLife.Reflection.Func">
            <summary>
            没有参数和返回值的委托
            </summary>
        </member>
        <member name="T:NewLife.Reflection.Func`1">
            <summary>
            具有指定类型返回的委托
            </summary>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`2">
            <summary>
            具有指定参数和返回的委托
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`3">
            <summary>
            具有指定两个参数和返回的委托
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`4">
            <summary>
            具有指定三个参数和返回的委托
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`5">
            <summary>
            具有指定四个参数和返回的委托
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Func`6">
            <summary>
            具有指定五个参数和返回的委托
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="arg"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <param name="arg5"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.TypeX">
            <summary>
            类型辅助类
            </summary>
        </member>
        <member name="T:NewLife.Reflection.MemberInfoX">
            <summary>
            快速访问成员
            </summary>
        </member>
        <member name="F:NewLife.Reflection.MemberInfoX.DefaultBinding">
            <summary>
            默认查找标志
            </summary>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.#ctor(System.Reflection.MemberInfo)">
            <summary>
            初始化
            </summary>
            <param name="member"></param>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.SaveIL(System.Reflection.MethodInfo,System.Action{System.Reflection.Emit.ILGenerator})">
            <summary>
            保存IL
            </summary>
            <param name="method"></param>
            <param name="action"></param>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.Invoke(System.Object,System.Object[])">
            <summary>
            执行方法
            </summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.GetValue(System.Object)">
            <summary>
            取值
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.SetValue(System.Object,System.Object)">
            <summary>
            赋值
            </summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.GetValue">
            <summary>
            静态 取值
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.SetValue(System.Object)">
            <summary>
            静态 赋值
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.CreateInstance(System.Object[])">
            <summary>
            创建实例
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.op_Implicit(NewLife.Reflection.MemberInfoX)~System.Reflection.MemberInfo">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.op_Implicit(System.Reflection.MemberInfo)~NewLife.Reflection.MemberInfoX">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MemberInfoX.HasRefParam(System.Reflection.MethodBase)">
            <summary>
            是否有引用参数
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Type">
            <summary>
            成员类型
            </summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.TargetType">
            <summary>
            目标类型
            </summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.IsType">
            <summary>
            是否类型
            </summary>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Item(System.Object)">
            <summary>
            属性/字段 索引器
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.MemberInfoX.Value">
            <summary>静态 属性/字段 值</summary>
        </member>
        <member name="M:NewLife.Reflection.TypeX.Create(System.Type)">
            <summary>
            创建类型辅助对象
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.CreateInstance(System.Object[])">
            <summary>
            创建实例
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.CreateInstance(System.Type,System.Object[])">
            <summary>
            快速反射创建指定类型的实例
            </summary>
            <param name="type"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetValue(System.Object)">
            <summary>
            取值，返回自己
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.IsPlugin(System.Type)">
            <summary>
            是否指定类型的插件
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetType(System.String)">
            <summary>
            根据名称获取类型
            </summary>
            <param name="typeName">类型名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetType(System.String,System.Boolean)">
            <summary>
            根据名称获取类型
            </summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetType(System.Reflection.Assembly,System.String)">
            <summary>
            从指定程序集查找指定名称的类型，如果查找不到，则进行忽略大小写的查找
            </summary>
            <param name="asm"></param>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.Equal(System.Type,System.Type)">
            <summary>
            判断两个类型是否相同，避免引用加载和执行上下文加载的相同类型显示不同
            </summary>
            <param name="type1"></param>
            <param name="type2"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetCustomAttributeValue``2">
            <summary>
            获取自定义属性的值。可用于ReflectionOnly加载的程序集
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.ChangeType(System.Object,System.Type)">
            <summary>
            类型转换
            </summary>
            <param name="value"></param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.ChangeType``1(System.Object)">
            <summary>
            类型转换
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.IsNullable(System.Type)">
            <summary>
            判断某个类型是否可空类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.GetTypeArray(System.Object[])">
            <summary>
            从参数数组中获取类型数组
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.op_Implicit(NewLife.Reflection.TypeX)~System.Type">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeX.op_Implicit(System.Type)~NewLife.Reflection.TypeX">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.TypeX.BaseType">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Handler">
            <summary>
            快速调用委托，延迟到首次使用才创建
            </summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Name">
            <summary>
            类型名称。主要处理泛型
            </summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.FullName">
            <summary>
            完整类型名称。包含命名空间，但是不包含程序集信息
            </summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.IsSystemType">
            <summary>
            是否系统类型
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Description">
            <summary>说明</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Members">
            <summary>所有成员</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Fields">
            <summary>字段集合</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Properties">
            <summary>属性集合</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Methods">
            <summary>方法集合</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Constructors">
            <summary>构造函数集合</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Events">
            <summary>事件集合</summary>
        </member>
        <member name="P:NewLife.Reflection.TypeX.Interfaces">
            <summary>接口集合</summary>
        </member>
        <member name="T:NewLife.Reflection.DynamicAssembly">
            <summary>
            全局方法程序集
            </summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicAssembly.AddGlobalMethod(System.Reflection.MethodInfo,System.Action{System.Reflection.Emit.ILGenerator})">
            <summary>
            添加全局方法
            </summary>
            <param name="method"></param>
            <param name="fun"></param>
        </member>
        <member name="M:NewLife.Reflection.DynamicAssembly.Save(System.String)">
            <summary>
            保存
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="P:NewLife.Reflection.DynamicAssembly.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Reflection.DynamicAssembly.AsmBuilder">
            <summary>程序集创建器</summary>
        </member>
        <member name="P:NewLife.Reflection.DynamicAssembly.ModBuilder">
            <summary>模块创建器</summary>
        </member>
        <member name="P:NewLife.Reflection.DynamicAssembly.TypeBuilder">
            <summary>类型创建器</summary>
        </member>
        <member name="T:NewLife.Serialization.IObjectMemberInfo">
            <summary>
            对象成员信息
            </summary>
        </member>
        <member name="P:NewLife.Serialization.IObjectMemberInfo.Name">
            <summary>
            名称
            </summary>
        </member>
        <member name="P:NewLife.Serialization.IObjectMemberInfo.Type">
            <summary>
            类型
            </summary>
        </member>
        <member name="P:NewLife.Serialization.IObjectMemberInfo.Item(System.Object)">
            <summary>
            对目标对象的该成员取值赋值
            </summary>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.IObjectMemberInfo.CanRead">
            <summary>
            是否可读
            </summary>
        </member>
        <member name="P:NewLife.Serialization.IObjectMemberInfo.CanWrite">
            <summary>
            是否可写
            </summary>
        </member>
        <member name="T:NewLife.Reflection.ITypeResolverProvider">
            <summary>
            类型解析器提供者接口
            </summary>
        </member>
        <member name="M:NewLife.Reflection.ITypeResolverProvider.Register(System.Type,System.Type)">
            <summary>
            注册类型，同一基类，解析时优先使用最后注册者
            </summary>
            <param name="baseType">基类</param>
            <param name="type">要注册的类型</param>
            <returns>返回自身，以便于连续注册</returns>
        </member>
        <member name="M:NewLife.Reflection.ITypeResolverProvider.Resolve(System.Type,System.Type[])">
            <summary>
            解析指定基类所注册的类型，排除指定类型，优先返回最后注册的类型
            </summary>
            <param name="baseType">基类</param>
            <param name="excludeTypes">排除类型，当没有排除类型以外的类型时，忽略排除类型返回最后注册的类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ITypeResolverProvider.ResolveAll(System.Type)">
            <summary>
            解析指定基类所注册的所有类型
            </summary>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.TypeResolverProvider">
            <summary>
            类型解析器提供者
            </summary>
        </member>
        <member name="M:NewLife.Reflection.TypeResolverProvider.Register(System.Type,System.Type)">
            <summary>
            注册类型，同一基类，解析时优先使用最后注册者
            </summary>
            <param name="baseType">基类</param>
            <param name="type">要注册的类型</param>
            <returns>返回自身，以便于连续注册</returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolverProvider.Resolve(System.Type,System.Type[])">
            <summary>
            解析指定基类所注册的类型，排除指定类型，优先返回最后注册的类型
            </summary>
            <param name="baseType">基类</param>
            <param name="excludeTypes">排除类型，当没有排除类型以外的类型时，忽略排除类型返回最后注册的类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolverProvider.ResolveAll(System.Type)">
            <summary>
            解析指定基类所注册的所有类型
            </summary>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.TypeResolverProvider.Maps">
            <summary>映射</summary>
        </member>
        <member name="T:NewLife.Reflection.TypeResolver">
            <summary>
            类型解析器
            </summary>
        </member>
        <member name="F:NewLife.Reflection.TypeResolver.provider">
            <summary>内部提供者</summary>
        </member>
        <member name="M:NewLife.Reflection.TypeResolver.Register(System.Type,System.Type)">
            <summary>
            注册类型，同一基类，获取时以最后一个类为准
            </summary>
            <param name="baseType">基类</param>
            <param name="type">要注册的类型</param>
            <returns>返回自身，以便于连续注册</returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolver.Register``2">
            <summary>
            注册类型
            </summary>
            <typeparam name="TBase">基类</typeparam>
            <typeparam name="T">要注册的类型</typeparam>
            <returns>返回自身，以便于连续注册</returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolver.Resolve(System.Type,System.Type[])">
            <summary>
            解析类型。
            </summary>
            <param name="baseType">基类</param>
            <param name="excludeTypes">排除类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolver.Resolve``2">
            <summary>
            解析类型
            </summary>
            <typeparam name="TBase"></typeparam>
            <typeparam name="TExclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolver.Resolve``1">
            <summary>
            解析类型
            </summary>
            <typeparam name="TBase"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolver.ResolveAll(System.Type)">
            <summary>
            解析类型
            </summary>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolver.ResolveAll``1">
            <summary>
            解析类型
            </summary>
            <typeparam name="TBase"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolver.GetObject(System.Type)">
            <summary>
            获取对象
            </summary>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolver.GetPropertyValue(System.Type,System.String)">
            <summary>
            取得指定类型的静态属性值
            </summary>
            <param name="baseType"></param>
            <param name="propertyName">属性名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.TypeResolver.Invoke(System.Type,System.String,System.Object[])">
            <summary>
            调用指定类型的静态方法
            </summary>
            <param name="baseType"></param>
            <param name="methodName"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.TypeResolver.Provider">
            <summary>提供者</summary>
        </member>
        <member name="T:NewLife.Log.TraceStream">
            <summary>
            跟踪流。继承自MemoryStream，主要用于重写Read/Write行为，跟踪程序操作数据流的过程
            </summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.Log.TraceStream.WriteByte(System.Byte)">
            <summary>
            写入一个字节
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Log.TraceStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            读取
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.ReadByte">
            <summary>
            读取一个字节
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.#ctor">
            <summary>
            实例化跟踪流
            </summary>
        </member>
        <member name="E:NewLife.Log.TraceStream.OnAction">
            <summary>
            操作时触发
            </summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.UseConsole">
            <summary>是否使用控制台</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.Encoding">
            <summary>编码</summary>
        </member>
        <member name="T:NewLife.Xml.XmlReaderWriterSettings">
            <summary>
            Xml序列化设置
            </summary>
        </member>
        <member name="T:NewLife.Serialization.TextReaderWriterSetting">
            <summary>
            字符串读写器设置
            </summary>
        </member>
        <member name="P:NewLife.Serialization.TextReaderWriterSetting.UseBase64">
            <summary>使用Base64编码字符串，否则使用十六进制字符串</summary>
        </member>
        <member name="P:NewLife.Serialization.TextReaderWriterSetting.UseEnumName">
            <summary>是否使用名称表示枚举类型，默认使用名称</summary>
        </member>
        <member name="P:NewLife.Serialization.TextReaderWriterSetting.WriteType">
            <summary>是否输出类型</summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderWriterSettings.MemberAsAttribute">
            <summary>成员作为属性</summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderWriterSettings.IgnoreDefault">
            <summary>忽略默认</summary>
        </member>
        <member name="T:NewLife.Web.WebClientX">
            <summary>
            扩展的Web客户端
            </summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetWebRequest(System.Uri)">
            <summary>
            重写获取请求
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetWebResponse(System.Net.WebRequest)">
            <summary>
            重写获取响应
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.#ctor">
            <summary>
            初始化常用的东西
            </summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Cookie">
            <summary>Cookie容器</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Timeout">
            <summary>超时，毫秒</summary>
        </member>
        <member name="T:NewLife.Common.HardInfo">
            <summary>
            硬件信息
            </summary>
        </member>
        <member name="M:NewLife.Common.HardInfo.ToExtend">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.HardInfo.FromExtend(NewLife.Xml.ExtendData)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.HardInfo.ToXml">
            <summary>
            导出XML
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.HardInfo.FromXml(System.String)">
            <summary>
            导入
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Common.HardInfo.MachineName">
            <summary>机器名</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.BaseBoard">
            <summary>主板</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Processors">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Disk">
            <summary>磁盘</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.DiskSerial">
            <summary>磁盘序列号</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Volume">
            <summary>驱动器序列号</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Macs">
            <summary>网卡</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.IPs">
            <summary>IP地址</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.OSVersion">
            <summary>系统版本</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Memory">
            <summary>内存</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.ScreenWidth">
            <summary>屏幕宽</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.ScreenHeight">
            <summary>屏幕高</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.DiskSize">
            <summary>磁盘大小</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo.Current">
            <summary>当前机器硬件信息</summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.MachineName">
            <summary>
            机器名
            </summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.BaseBoard">
            <summary>
            主板序列号
            </summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.Processors">
            <summary>
            处理器序列号
            </summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.Memory">
            <summary>
            内存总量
            </summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.Disk">
            <summary>
            磁盘名称
            </summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.DiskSerial">
            <summary>
            磁盘序列号
            </summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.Volume">
            <summary>
            驱动器序列号
            </summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.Macs">
            <summary>
            网卡地址序列号
            </summary>
        </member>
        <member name="P:NewLife.Common.HardInfo._.IPs">
            <summary>
            IP地址
            </summary>
        </member>
        <member name="T:NewLife.Remoting.MethodMessage">
            <summary>
            方法消息
            </summary>
        </member>
        <member name="P:NewLife.Remoting.MethodMessage.MessageType">
            <summary>消息类型</summary>
        </member>
        <member name="T:NewLife.Reflection.FastTest">
            <summary>
            快速反射测试
            </summary>
        </member>
        <member name="M:NewLife.Reflection.FastTest.Test">
            <summary>
            
            </summary>
        </member>
        <member name="M:NewLife.Reflection.FastTest.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NewLife.Reflection.FastTest.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:NewLife.Reflection.FastTest.#ctor(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="id"></param>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Reflection.FastTest.GetFullName(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="id"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.FastTest.ID">
            <summary>编号</summary>
        </member>
        <member name="P:NewLife.Reflection.FastTest.Name">
            <summary>名称</summary>
        </member>
        <member name="T:NewLife.Serialization.BinaryReaderX">
            <summary>
            二进制读取器
            </summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadByte">
            <summary>
            读取字节
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadBytes(System.Int32)">
            <summary>
            从当前流中将 count 个字节读入字节数组，并使当前位置提升 count 个字节。
            </summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadIntBytes(System.Int32)">
            <summary>
            判断字节顺序
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.Reset">
            <summary>
            重置
            </summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadInt16">
            <summary>
            从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadInt32">
            <summary>
            从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadInt64">
            <summary>
            从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadEncodedInt16">
            <summary>
            以压缩格式读取16位整数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadEncodedInt32">
            <summary>
            以压缩格式读取32位整数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadEncodedInt64">
            <summary>
            以压缩格式读取64位整数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.OnReadType">
            <summary>
            读取Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.ReadRefObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取引用对象
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.GetMemberBeforeRead(System.Type,System.Object,NewLife.Serialization.IObjectMemberInfo[],System.Int32)">
            <summary>
            读取成员之前获取要读取的成员，默认是index处的成员，实现者可以重载，改变当前要读取的成员，如果当前成员不在数组里面，则实现者自己跳到下一个可读成员。
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="members">可匹配成员数组</param>
            <param name="index">索引</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryReaderX.OnGetMembers(System.Type,System.Object)">
            <summary>
            获取需要序列化的成员
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <returns>需要序列化的成员</returns>
        </member>
        <member name="P:NewLife.Serialization.BinaryReaderX.Reader">
            <summary>读取器</summary>
        </member>
        <member name="P:NewLife.Serialization.BinaryReaderX.Stream">
            <summary>
            数据流。更改数据流后，重置Reader为空，以使用新的数据流
            </summary>
        </member>
        <member name="T:NewLife.Threading.TimerX">
            <summary>
            不可重入的定时器。为了避免系统的Timer可重入的问题，差别在于本地调用完成后才开始计算时间间隔。这实际上也是经常用到的。
            </summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.WaitCallback,System.Object,System.Int32,System.Int32)">
            <summary>
            实例化
            </summary>
            <param name="callback"></param>
            <param name="state"></param>
            <param name="dueTime"></param>
            <param name="period"></param>
        </member>
        <member name="M:NewLife.Threading.TimerX.OnDispose(System.Boolean)">
            <summary>
            销毁时触发
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Threading.TimerX.Callback">
            <summary>回调</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.State">
            <summary>用户数据</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.NextTime">
            <summary>下一次调用时间</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Timers">
            <summary>调用次数</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Period">
            <summary>间隔周期</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Calling">
            <summary>调用中</summary>
        </member>
        <member name="T:NewLife.Messaging.MessageStreamHandler">
            <summary>
            用于消息的数据流处理器。
            </summary>
        </member>
        <member name="T:NewLife.IO.StreamHandler">
            <summary>
            数据流处理器
            </summary>
        </member>
        <member name="T:NewLife.IO.IStreamHandler">
            <summary>
            数据流处理器接口
            </summary>
        </member>
        <member name="M:NewLife.IO.IStreamHandler.Process(System.IO.Stream)">
            <summary>
            处理数据流
            </summary>
            <param name="stream">待处理数据流</param>
            <returns>转发给下一个处理器的数据流，如果不想让后续处理器处理，返回空</returns>
        </member>
        <member name="P:NewLife.IO.IStreamHandler.IsReusable">
            <summary>
            是否可以重用。
            </summary>
        </member>
        <member name="M:NewLife.IO.StreamHandler.Process(System.IO.Stream)">
            <summary>
            处理数据流
            </summary>
            <param name="stream"></param>
            <returns>转发给下一个处理器的数据流，如果不想让后续处理器处理，返回空</returns>
        </member>
        <member name="M:NewLife.IO.StreamHandler.Register(System.String,NewLife.IO.IStreamHandler,System.Boolean)">
            <summary>
            注册数据流处理器。
            数据流到达时将进入指定通道的每一个处理器。
            不同通道名称的处理器互不干扰。
            不提供注册到指定位置的功能，如果需要，再以多态方式实现。
            </summary>
            <param name="name">通道名称，用于区分数据流总线</param>
            <param name="handler">数据流处理器</param>
            <param name="cover">是否覆盖原有同类型处理器</param>
        </member>
        <member name="M:NewLife.IO.StreamHandler.QueryRegister(System.String)">
            <summary>
            查询注册，返回指定通道的处理器数组。
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHandler.GetHandler">
            <summary>
            获取配置文件指定的处理器
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHandler.LoadConfig">
            <summary>
            从配置文件中加载工厂
            </summary>
        </member>
        <member name="M:NewLife.IO.StreamHandler.Process(System.String,System.IO.Stream)">
            <summary>
            处理数据流。Http、Tcp、Udp等所有数据流都将到达这里，多种传输方式汇聚于此，由数据流总线统一处理！
            </summary>
            <param name="name"></param>
            <param name="stream"></param>
        </member>
        <member name="P:NewLife.IO.StreamHandler.IsReusable">
            <summary>
            是否可以重用
            </summary>
        </member>
        <member name="T:NewLife.Messaging.NullMessage">
            <summary>
            空消息
            </summary>
        </member>
        <member name="P:NewLife.Messaging.NullMessage.ID">
            <summary>
            消息编号
            </summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterState.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterState.Target">
            <summary>目标对象</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterState.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Serialization.ReaderWriterState.Member">
            <summary>成员</summary>
        </member>
        <member name="T:NewLife.Xml.XmlReaderX">
            <summary>
            Xml读取器
            </summary>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.#ctor(System.String)">
            <summary>
            使用xml字符串初始化
            </summary>
            <param name="xml"></param>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadString">
            <summary>
            从当前流中读取一个字符串。字符串有长度前缀，一次 7 位地被编码为整数。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.OnReadType">
            <summary>
            读对象类型
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadDictionary(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取字典类型对象
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.OnReadDictionaryEntry(System.Type,System.Type,System.Collections.DictionaryEntry@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取字典项
            </summary>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="value">字典项</param>
            <param name="index">元素序号</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadEnumerable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取枚举
            </summary>
            <remarks>重点和难点在于如果得知枚举元素类型，这里假设所有元素类型一致，否则实在无法处理</remarks>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.OnReadItem(System.Type,System.Object@,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取项
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="index">元素序号</param>
            <param name="callback">处理元素的方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.OnReadObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取目标对象指定成员的值，通过委托方法递归处理成员
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadRefObject(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            尝试读取引用对象
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.GetMemberBeforeRead(System.Type,System.Object,NewLife.Serialization.IObjectMemberInfo[],System.Int32)">
            <summary>
            读取成员之前获取要读取的成员，默认是index处的成员，实现者可以重载，改变当前要读取的成员，如果当前成员不在数组里面，则实现者自己跳到下一个可读成员。
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="members">可匹配成员数组</param>
            <param name="index">索引</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.OnReadMember(System.Type,System.Object@,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取成员
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.OnReadObjRefIndex">
            <summary>
            读取对象引用计数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadUnKnown(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取未知对象（其它所有方法都无法识别的对象），采用BinaryFormatter或者XmlSerialization
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.SkipEmpty">
            <summary>
            当前节点是否空。如果是空节点，则读一次，让指针移到下一个元素
            </summary>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadLengths">
            <summary>
            读取多维数组相关参数
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlReaderX.ReadSerializable(System.Type,System.Object@,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            读取实现了可序列化接口的对象
            </summary>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="P:NewLife.Xml.XmlReaderX.Reader">
            <summary>读取器</summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderX.Stream">
            <summary>
            数据流。更改数据流后，重置Reader为空，以使用新的数据流
            </summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderX.RootName">
            <summary>根元素名</summary>
        </member>
        <member name="P:NewLife.Xml.XmlReaderX.Lengths">
            <summary>多维数组长度</summary>
        </member>
        <member name="T:NewLife.Reflection.EmitHelper">
            <summary>
            动态生成代码Emit助手。仅提供扩展功能，不封装基本功能
            </summary>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.#ctor(System.Reflection.Emit.ILGenerator)">
            <summary>
            实例化
            </summary>
            <param name="il"></param>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldc_I4(System.Int32)">
            <summary>
            基于Ldc_I4指令的整数推送，自动选择最合适的指令
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldarg(System.Int32)">
            <summary>
            基于Ldarg指令的参数加载，自动选择最合适的指令
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Stloc(System.Int32)">
            <summary>
            基于Stloc指令的弹栈，自动选择最合适的指令
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldloc(System.Int32)">
            <summary>
            基于Ldloc指令的压栈，自动选择最合适的指令
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldfld(System.Reflection.FieldInfo)">
            <summary>
            查找对象中其引用当前位于计算堆栈的字段的值。
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldind(System.Type)">
            <summary>
            间接加载到计算堆栈
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Stind(System.Type)">
            <summary>
            间接加载到计算堆栈
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldelem_Ref">
            <summary>
            将位于指定数组索引处的包含对象引用的元素作为 O 类型（对象引用）加载到计算堆栈的顶部。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Stelem_Ref">
            <summary>
            用计算堆栈上的对象 ref 值（O 类型）替换给定索引处的数组元素。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.CastFromObject(System.Type)">
            <summary>
            把一个类型转为指定类型，值类型装箱，引用类型直接Cast
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.BoxIfValueType(System.Type)">
            <summary>
            装箱
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Call(System.Reflection.MethodInfo)">
            <summary>
            调用
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldnull">
            <summary>
            加载空
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ret">
            <summary>
            返回
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.NewValueType(System.Type)">
            <summary>
            创建值类型，对象位于栈上
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.NewArray(System.Type)">
            <summary>
            创建数组，参数必须是Object[]
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.NewObj(System.Reflection.ConstructorInfo)">
            <summary>
            创建对象
            </summary>
            <param name="constructor"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.CreateLocalsForByRefParams(System.Reflection.MethodBase)">
            <summary>
            为引用参数声明本地变量
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.AssignByRefParamsToArray(System.Reflection.MethodBase)">
            <summary>
            将引用参数赋值到数组
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.PushParamsOrLocalsToStack(System.Reflection.MethodBase)">
            <summary>
            将参数压栈
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.PushParams(System.Int32,System.Reflection.MethodBase)">
            <summary>
            将指定参数位置的数组参数按照方法参数要求压栈
            </summary>
            <param name="paramIndex"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.PushParams(System.Int32,System.Type[])">
            <summary>
            将指定参数位置的数组参数一个个压栈
            </summary>
            <param name="paramIndex"></param>
            <param name="paramTypes"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.EmitHelper.IL">
            <summary>IL代码生成器</summary>
        </member>
        <member name="T:NewLife.Reflection.AttributeX">
            <summary>
            特性辅助类
            </summary>
        </member>
        <member name="M:NewLife.Reflection.AttributeX.GetCustomAttribute``1(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            获取自定义属性
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="member"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AttributeX.GetCustomAttributeValue``2(System.Reflection.Assembly)">
            <summary>
            获取自定义属性的值。可用于ReflectionOnly加载的程序集
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AttributeX.GetCustomAttributeValue``2(System.Type,System.Boolean)">
            <summary>
            获取自定义属性的值。可用于ReflectionOnly加载的程序集
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="target"></param>
            <param name="inherit">是否递归</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.MethodInfoX">
            <summary>
            快速调用。基于DynamicMethod和Emit实现。
            </summary>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Create(System.Reflection.MethodInfo)">
            <summary>
            创建
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Create(System.Type,System.String)">
            <summary>
            创建
            </summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Create(System.Type,System.String,System.Type[])">
            <summary>
            创建
            </summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramTypes">参数类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Invoke(System.Object,System.Object[])">
            <summary>
            参数调用
            </summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.InvokeByDictionaryParameter(System.Object,System.Collections.IDictionary)">
            <summary>
            通过字典参数调用
            </summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Invoke``1(System.Object,System.String,System.Object[])">
            <summary>
            快速调用方法成员
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="target"></param>
            <param name="name"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.Invoke``2(System.String,System.Object[])">
            <summary>
            快速调用静态方法
            </summary>
            <typeparam name="TTarget">目标类型</typeparam>
            <typeparam name="TResult">返回类型</typeparam>
            <param name="name"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.InvokeByDictionaryParameter``1(System.Object,System.String,System.Collections.IDictionary)">
            <summary>
            通过传入参数字典快速调用方法
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="target"></param>
            <param name="name"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.InvokeByDictionaryParameter``2(System.String,System.Collections.IDictionary)">
            <summary>
            通过传入参数字典快速调用静态方法
            </summary>
            <typeparam name="TTarget"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="name"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.op_Implicit(NewLife.Reflection.MethodInfoX)~System.Reflection.MethodInfo">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.MethodInfoX.op_Implicit(System.Reflection.MethodInfo)~NewLife.Reflection.MethodInfoX">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.MethodInfoX.Method">
            <summary>目标方法</summary>
        </member>
        <member name="P:NewLife.Reflection.MethodInfoX.Handler">
            <summary>
            快速调用委托，延迟到首次使用才创建
            </summary>
        </member>
        <member name="T:NewLife.Reflection.MethodInfoX.FastInvokeHandler">
            <summary>
            快速调用委托
            </summary>
            <param name="obj"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.WriteMemberEventArgs">
            <summary>
            写入成员事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.WriteMemberEventArgs.#ctor(System.Object,System.Type,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="value">对象</param>
            <param name="type">对象类型</param>
            <param name="member">成员</param>
            <param name="index">成员序号</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.WriteMemberEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.WriteMemberEventArgs.Type">
            <summary>对象类型</summary>
        </member>
        <member name="P:NewLife.Serialization.WriteMemberEventArgs.Member">
            <summary>成员</summary>
        </member>
        <member name="T:NewLife.Reflection.PropertyInfoX">
            <summary>
            快速属性访问
            </summary>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.Create(System.Reflection.PropertyInfo)">
            <summary>
            创建
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.Create(System.Type,System.String)">
            <summary>
            创建
            </summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.GetValue(System.Object)">
            <summary>
            取值
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.SetValue(System.Object,System.Object)">
            <summary>
            赋值
            </summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.GetValue``1(System.Object,System.String)">
            <summary>
            静态快速取值
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="target"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.GetValue``2(System.String)">
            <summary>
            快速获取静态属性
            </summary>
            <typeparam name="TTarget"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.SetValue(System.Object,System.String,System.Object)">
            <summary>
            静态快速赋值
            </summary>
            <param name="target"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.SetValue``1(System.String,System.Object)">
            <summary>
            快速设置静态属性
            </summary>
            <typeparam name="TTarget"></typeparam>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.op_Implicit(NewLife.Reflection.PropertyInfoX)~System.Reflection.PropertyInfo">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PropertyInfoX.op_Implicit(System.Reflection.PropertyInfo)~NewLife.Reflection.PropertyInfoX">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.Property">
            <summary>目标属性</summary>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.GetMethod">
            <summary>读取方法</summary>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.SetMethod">
            <summary>设置方法</summary>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.GetHandler">
            <summary>
            快速调用委托，延迟到首次使用才创建
            </summary>
        </member>
        <member name="P:NewLife.Reflection.PropertyInfoX.SetHandler">
            <summary>
            快速调用委托，延迟到首次使用才创建
            </summary>
        </member>
        <member name="T:NewLife.Serialization.WriteDictionaryEventArgs">
            <summary>
            写入字典项事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.WriteDictionaryEventArgs.#ctor(System.Collections.DictionaryEntry,System.Type,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="value">对象</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="index"></param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.WriteDictionaryEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.WriteDictionaryEventArgs.KeyType">
            <summary>键类型</summary>
        </member>
        <member name="P:NewLife.Serialization.WriteDictionaryEventArgs.ValueType">
            <summary>值类型</summary>
        </member>
        <member name="T:NewLife.Reflection.ConstructorInfoX">
            <summary>
            快速调用构造函数。基于DynamicMethod和Emit实现。
            </summary>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.Create(System.Reflection.ConstructorInfo)">
            <summary>
            创建
            </summary>
            <param name="constructor"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.Create(System.Type,System.Type[])">
            <summary>
            创建
            </summary>
            <param name="type"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.Create(System.Type)">
            <summary>
            创建
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.CreateInstance(System.Object[])">
            <summary>
            创建实例
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.op_Implicit(NewLife.Reflection.ConstructorInfoX)~System.Reflection.ConstructorInfo">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ConstructorInfoX.op_Implicit(System.Reflection.ConstructorInfo)~NewLife.Reflection.ConstructorInfoX">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.ConstructorInfoX.Constructor">
            <summary>目标方法</summary>
        </member>
        <member name="P:NewLife.Reflection.ConstructorInfoX.Handler">
            <summary>
            快速调用委托，延迟到首次使用才创建
            </summary>
        </member>
        <member name="T:NewLife.Serialization.ReadItemEventArgs">
            <summary>
            读取枚举项事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.ReadItemEventArgs.#ctor(System.Object,System.Type,System.Int32,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="value">对象</param>
            <param name="type">对象类型</param>
            <param name="index">序号</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.ReadItemEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.ReadItemEventArgs.Type">
            <summary>对象类型</summary>
        </member>
        <member name="T:NewLife.Serialization.BinarySettings">
            <summary>
            二进制序列化设置
            </summary>
        </member>
        <member name="P:NewLife.Serialization.BinarySettings.IsLittleEndian">
            <summary>
            是否小端字节序。
            </summary>
            <remarks>
            网络协议都是Big-Endian；
            Java编译的都是Big-Endian；
            Motorola的PowerPC是Big-Endian；
            x86系列则采用Little-Endian方式存储数据；
            ARM同时支持 big和little，实际应用中通常使用Little-Endian。
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.BinarySettings.EncodeInt">
            <summary>编码整数。打开后将使用7位编码写入所有16、32和64位整数，节省空间。打开后字节序设置将会无效。默认打开。</summary>
        </member>
        <member name="P:NewLife.Serialization.BinarySettings.IgnoreType">
            <summary>忽略类型。打开后将不输出对象类型，按照读取时指定的类型读取。默认打开。</summary>
        </member>
        <member name="P:NewLife.Serialization.BinarySettings.IgnoreName">
            <summary>忽略名称。打开后将不输出成员名称，按照读取时指定的类型读取。默认打开。</summary>
        </member>
        <member name="P:NewLife.Serialization.BinarySettings.SplitComplexType">
            <summary>是否拆分复杂类型。将拆分数组、内嵌和泛型</summary>
        </member>
        <member name="T:NewLife.Serialization.BinarySettings.TypeKinds">
            <summary>
            类型样式
            </summary>
        </member>
        <member name="F:NewLife.Serialization.BinarySettings.TypeKinds.Normal">
            <summary>
            普通类型
            </summary>
        </member>
        <member name="F:NewLife.Serialization.BinarySettings.TypeKinds.Array">
            <summary>
            数组类型
            </summary>
        </member>
        <member name="F:NewLife.Serialization.BinarySettings.TypeKinds.Nested">
            <summary>
            内嵌类型
            </summary>
        </member>
        <member name="F:NewLife.Serialization.BinarySettings.TypeKinds.Generic">
            <summary>
            泛型类型
            </summary>
        </member>
        <member name="T:NewLife.Log.TextFileLog">
            <summary>
            文本文件日志类。提供向文本文件写日志的能力
            </summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Create(System.String)">
            <summary>
            每个目录的日志实例应该只有一个，所以采用静态创建
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Log.TextFileLog.isFirst">
            <summary>
            是否当前进程的第一次写日志
            </summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.InitLog">
            <summary>
            初始化日志记录文件
            </summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.CloseWriter(System.Object)">
            <summary>
            停止日志
            </summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.PerformWriteLog(System.Object)">
            <summary>
            使用线程池线程异步执行日志写入动作
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.WriteLine(System.String)">
            <summary>
            输出日志
            </summary>
            <param name="msg">信息</param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.DebugStack">
            <summary>
            堆栈调试。
            输出堆栈信息，用于调试时处理调用上下文。
            本方法会造成大量日志，请慎用。
            </summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.DebugStack(System.Int32)">
            <summary>
            堆栈调试。
            </summary>
            <param name="maxNum">最大捕获堆栈方法数</param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.WriteLine(System.String,System.Object[])">
            <summary>
            写日志
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="P:NewLife.Log.TextFileLog.FilePath">
            <summary>文件路径</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.LogPath">
            <summary>
            日志目录
            </summary>
        </member>
        <member name="E:NewLife.Log.TextFileLog.OnWriteLog">
            <summary>
            写日志事件。绑定该事件后，XTrace将不再把日志写到日志文件中去。
            </summary>
        </member>
        <member name="T:NewLife.WeakAction`1">
            <summary>
            弱引用Action
            </summary>
            <typeparam name="TArgs"></typeparam>
        </member>
        <member name="F:NewLife.WeakAction`1.Target">
            <summary>
            目标对象。弱引用，使得调用方对象可以被GC回收
            </summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Method">
            <summary>
            委托方法
            </summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Handler">
            <summary>
            经过包装的新的委托
            </summary>
        </member>
        <member name="F:NewLife.WeakAction`1.UnHandler">
            <summary>
            取消注册的委托
            </summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Once">
            <summary>
            是否只使用一次，如果只使用一次，执行委托后马上取消注册
            </summary>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Object,System.Reflection.MethodInfo)">
            <summary>
            实例化
            </summary>
            <param name="target"></param>
            <param name="method"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Object,System.Reflection.MethodInfo,System.Action{System.Action{`0}},System.Boolean)">
            <summary>
            实例化
            </summary>
            <param name="target"></param>
            <param name="method"></param>
            <param name="unHandler"></param>
            <param name="once"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Delegate)">
            <summary>
            实例化
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Delegate,System.Action{System.Action{`0}},System.Boolean)">
            <summary>
            使用事件处理器、取消注册回调、是否一次性事件来初始化
            </summary>
            <param name="handler"></param>
            <param name="unHandler"></param>
            <param name="once"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.Invoke(`0)">
            <summary>
            调用委托
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.op_Implicit(NewLife.WeakAction{`0})~System.Action{`0}">
            <summary>
            把弱引用事件处理器转换为普通事件处理器
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.WeakAction`1.IsAlive">
            <summary>
            是否可用
            </summary>
        </member>
        <member name="T:NewLife.Collections.ListX`1">
            <summary>
            增强的强类型列表
            </summary>
        </member>
        <member name="M:NewLife.Collections.ListX`1.#ctor">
            <summary>
            构造一个实体对象集合
            </summary>
        </member>
        <member name="M:NewLife.Collections.ListX`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            构造一个实体对象集合
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:NewLife.Collections.ListX`1.#ctor(System.Int32)">
            <summary>
            构造一个实体对象集合
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:NewLife.Collections.ListX`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            初始化
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:NewLife.Collections.ListX`1.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.op_Addition(NewLife.Collections.ListX{`0},NewLife.Collections.ListX{`0})">
            <summary>
            集合相加
            </summary>
            <param name="list1">第一个实体集合</param>
            <param name="list2">第二个实体集合</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.op_Subtraction(NewLife.Collections.ListX{`0},NewLife.Collections.ListX{`0})">
            <summary>
            集合相减
            </summary>
            <param name="list1">第一个实体集合</param>
            <param name="list2">第二个实体集合</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            从集合中移除另一个集合指定的元素
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:NewLife.Collections.ListX`1.FindAll(System.String,System.Object)">
            <summary>
            根据指定项查找
            </summary>
            <param name="name">属性名</param>
            <param name="value">属性值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.FindAll(System.Predicate{`0})">
            <summary>
            检索与指定谓词定义的条件匹配的所有元素。
            </summary>
            <param name="match">条件</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.Find(System.String,System.Object)">
            <summary>
            根据指定项查找
            </summary>
            <param name="name">属性名</param>
            <param name="value">属性值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.FindAllIgnoreCase(System.String,System.String)">
            <summary>
            根据指定项查找字符串。忽略大小写
            </summary>
            <param name="name">属性名</param>
            <param name="value">属性值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.FindIgnoreCase(System.String,System.String)">
            <summary>
            根据指定项查找字符串。忽略大小写
            </summary>
            <param name="name">属性名</param>
            <param name="value">属性值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.Exists(System.String,System.Object)">
            <summary>
            集合是否包含指定项
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.Sort(System.String,System.Boolean)">
            <summary>
            按指定字段排序
            </summary>
            <param name="name">字段</param>
            <param name="isDesc">是否降序</param>
        </member>
        <member name="M:NewLife.Collections.ListX`1.Sort(System.String[],System.Boolean[])">
            <summary>
            按指定字段数组排序
            </summary>
            <param name="names">字段</param>
            <param name="isDescs">是否降序</param>
        </member>
        <member name="M:NewLife.Collections.ListX`1.GetItem``1(System.String)">
            <summary>
            获取所有实体中指定项的值
            </summary>
            <typeparam name="TResult">指定项的类型</typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.Export(System.IO.TextWriter)">
            <summary>
            导出
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:NewLife.Collections.ListX`1.Import(System.IO.TextReader)">
            <summary>
            导入
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.ToXml">
            <summary>
            导出Xml文本
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.FromXml(System.String)">
            <summary>
            导入Xml文本
            </summary>
            <param name="xml"></param>
        </member>
        <member name="M:NewLife.Collections.ListX`1.From(System.Collections.IEnumerable)">
            <summary>
            任意集合转为实体集合
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.From``1(System.Collections.IEnumerable,NewLife.Reflection.Func{``0,`0})">
            <summary>
            拥有指定类型转换器的转换
            </summary>
            <typeparam name="T2"></typeparam>
            <param name="collection"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.GetValue(System.Object,System.String)">
            <summary>
            快速取值，如果实现了IIndexAccessor接口，则优先采用
            </summary>
            <param name="target"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ListX`1.Clone">
            <summary>
            克隆
            </summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.HttpStream">
            <summary>
            HTTP输入输出流
            </summary>
        </member>
        <member name="M:NewLife.Web.HttpStream.#ctor(System.Web.HttpContext)">
            <summary>
            初始化
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.HttpStream.Flush">
            <summary>
            已重载。
            </summary>
        </member>
        <member name="P:NewLife.Web.HttpStream.Context">
            <summary>HTTP上下文</summary>
        </member>
        <member name="P:NewLife.Web.HttpStream.RemoteEndPoint">
            <summary>远程地址</summary>
        </member>
        <member name="T:NewLife.Threading.TaskState">
            <summary>
            任务状态
            </summary>
        </member>
        <member name="F:NewLife.Threading.TaskState.Unstarted">
            <summary>
            未处理
            </summary>
        </member>
        <member name="F:NewLife.Threading.TaskState.Running">
            <summary>
            正在处理
            </summary>
        </member>
        <member name="F:NewLife.Threading.TaskState.Finished">
            <summary>
            已完成
            </summary>
        </member>
        <member name="T:NewLife.Remoting.RemotingMessageHandler">
            <summary>
            远程调用消息处理器
            </summary>
        </member>
        <member name="T:NewLife.Messaging.MessageHandler">
            <summary>
            消息处理器
            </summary>
        </member>
        <member name="T:NewLife.Messaging.IMessageHandler">
            <summary>
            消息处理器接口
            </summary>
        </member>
        <member name="M:NewLife.Messaging.IMessageHandler.Create(System.Int32)">
            <summary>
            创建指定编号的消息
            </summary>
            <param name="messageID"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.IMessageHandler.Process(NewLife.Messaging.Message,System.IO.Stream)">
            <summary>
            处理消息
            </summary>
            <param name="message">消息</param>
            <param name="stream">数据流，已经从里面读取消息实体</param>
            <returns>转发给下一个处理器的数据流，如果不想让后续处理器处理，返回空</returns>
        </member>
        <member name="P:NewLife.Messaging.IMessageHandler.IsReusable">
            <summary>
            是否可以重用。
            </summary>
        </member>
        <member name="M:NewLife.Messaging.MessageHandler.Create(System.Int32)">
            <summary>
            创建消息
            </summary>
            <param name="messageID"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageHandler.Process(NewLife.Messaging.Message,System.IO.Stream)">
            <summary>
            处理消息
            </summary>
            <param name="message">消息</param>
            <param name="stream">数据流，已经从里面读取消息实体</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageHandler.Register(System.Int32,NewLife.Messaging.IMessageHandler,System.Boolean)">
            <summary>
            注册数据流处理器。
            数据流到达时将进入指定通道的每一个处理器。
            不同通道名称的处理器互不干扰。
            不提供注册到指定位置的功能，如果需要，再以多态方式实现。
            </summary>
            <param name="id">通道名称，用于区分数据流总线</param>
            <param name="handler">数据流处理器</param>
            <param name="cover">是否覆盖原有同类型处理器</param>
        </member>
        <member name="M:NewLife.Messaging.MessageHandler.QueryRegister(System.Int32)">
            <summary>
            查询注册，返回指定通道的处理器数组。
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageHandler.Support(System.Int32)">
            <summary>
            是否支持指定类型的消息
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageHandler.GetHandler">
            <summary>
            获取配置文件指定的处理器
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageHandler.LoadConfig">
            <summary>
            从配置文件中加载工厂
            </summary>
        </member>
        <member name="M:NewLife.Messaging.MessageHandler.CreateMessage(System.Int32)">
            <summary>
            创建指定编号的消息
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.MessageHandler.Process(System.IO.Stream)">
            <summary>
            处理消息
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Messaging.MessageHandler.Process(System.IO.Stream,NewLife.Messaging.MessageExceptionOption)">
            <summary>
            处理消息
            </summary>
            <param name="stream"></param>
            <param name="option"></param>
        </member>
        <member name="P:NewLife.Messaging.MessageHandler.IsReusable">
            <summary>
            是否可以重用
            </summary>
        </member>
        <member name="E:NewLife.Messaging.MessageHandler.Received">
            <summary>
            消息到达时触发
            </summary>
        </member>
        <member name="E:NewLife.Messaging.MessageHandler.Error">
            <summary>
            异常发生时触发
            </summary>
        </member>
        <member name="E:NewLife.Messaging.MessageHandler.Null">
            <summary>
            空消息发生时触发
            </summary>
        </member>
        <member name="T:NewLife.Messaging.MessageHandler.DefaultMessageHandler">
            <summary>
            异常消息处理器
            </summary>
        </member>
        <member name="M:NewLife.Remoting.RemotingMessageHandler.#cctor">
            <summary>
            静态构造函数
            </summary>
        </member>
        <member name="M:NewLife.Remoting.RemotingMessageHandler.Init">
            <summary>
            初始化，用于注册所有消息
            </summary>
        </member>
        <member name="M:NewLife.Remoting.RemotingMessageHandler.Create(System.Int32)">
            <summary>
            建立消息
            </summary>
            <param name="messageID"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.RemotingMessageHandler.Process(NewLife.Messaging.Message,System.IO.Stream)">
            <summary>
            处理消息
            </summary>
            <param name="message"></param>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.RemotingClient">
            <summary>
            远程客户端
            </summary>
        </member>
        <member name="P:NewLife.Remoting.RemotingClient.Client">
            <summary>数据流客户端</summary>
        </member>
        <member name="T:NewLife.IO.StreamHttpHandler">
            <summary>
            数据流Http处理器。可以在web.config中配置一个处理器指向该类。
            </summary>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.ProcessRequest(System.Web.HttpContext)">
            <summary>
            处理请求
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.OnProcess(System.Web.HttpContext)">
            <summary>
            处理请求
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.GetName(System.Web.HttpContext)">
            <summary>
            从Http上下文获取数据流总线名称
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.GetStream(System.Web.HttpContext)">
            <summary>
            从Http上下文获取数据流
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.ToHex(System.Byte[])">
            <summary>
            加密
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.StreamHttpHandler.FromHex(System.String)">
            <summary>
            解密
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.IO.StreamHttpHandler.IsReusable">
            <summary>
            是否可以重用
            </summary>
        </member>
        <member name="T:NewLife.Collections.Triplet">
            <summary>
            三个一组
            </summary>
        </member>
        <member name="F:NewLife.Collections.Triplet.First">
            <summary>
            第一个
            </summary>
        </member>
        <member name="F:NewLife.Collections.Triplet.Second">
            <summary>
            第二个
            </summary>
        </member>
        <member name="F:NewLife.Collections.Triplet.Third">
            <summary>
            第三个
            </summary>
        </member>
        <member name="M:NewLife.Collections.Triplet.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Collections.Triplet.#ctor(System.Object,System.Object)">
            <summary>
            初始化
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:NewLife.Collections.Triplet.#ctor(System.Object,System.Object,System.Object)">
            <summary>
            初始化
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:NewLife.Collections.Triplet.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.Triplet`3">
            <summary>
            泛型三个一组
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <typeparam name="TThird"></typeparam>
        </member>
        <member name="F:NewLife.Collections.Triplet`3.First">
            <summary>
            第一个
            </summary>
        </member>
        <member name="F:NewLife.Collections.Triplet`3.Second">
            <summary>
            第二个
            </summary>
        </member>
        <member name="F:NewLife.Collections.Triplet`3.Third">
            <summary>
            第三个
            </summary>
        </member>
        <member name="M:NewLife.Collections.Triplet`3.#ctor">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:NewLife.Collections.Triplet`3.#ctor(`0,`1)">
            <summary>
            初始化
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:NewLife.Collections.Triplet`3.#ctor(`0,`1,`2)">
            <summary>
            初始化
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:NewLife.Collections.Triplet`3.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.CompressionModule">
            <summary>
            页面压缩模块
            </summary>
        </member>
        <member name="M:NewLife.Web.CompressionModule.System#Web#IHttpModule#Init(System.Web.HttpApplication)">
            <summary>
            初始化模块，准备拦截请求。
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.CompressionModule.IsEncodingAccepted(System.String)">
            <summary>
            Checks the request headers to see if the specified
            encoding is accepted by the client.
            </summary>
        </member>
        <member name="M:NewLife.Web.CompressionModule.SetEncoding(System.String)">
            <summary>
            Adds the specified encoding to the response headers.
            </summary>
            <param name="encoding"></param>
        </member>
        <member name="T:NewLife.Serialization.ReadObjectEventArgs">
            <summary>
            读取对象事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.ReadObjectEventArgs.#ctor(System.Object,System.Type,NewLife.Serialization.ReadObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="value">对象</param>
            <param name="type">对象类型</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.ReadObjectEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.ReadObjectEventArgs.Type">
            <summary>对象类型</summary>
        </member>
        <member name="T:NewLife.Serialization.SimpleMemberInfo">
            <summary>
            简单成员信息
            </summary>
        </member>
        <member name="M:NewLife.Serialization.SimpleMemberInfo.#ctor(System.String,System.Type,System.Object)">
            <summary>
            实例化
            </summary>
            <param name="name"></param>
            <param name="type"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.SimpleMemberInfo.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.SimpleMemberInfo.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Serialization.SimpleMemberInfo.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Serialization.SimpleMemberInfo.Item(System.Object)">
            <summary>
            对目标对象取值赋值
            </summary>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.SimpleMemberInfo.CanRead">
            <summary>
            是否可读
            </summary>
        </member>
        <member name="P:NewLife.Serialization.SimpleMemberInfo.CanWrite">
            <summary>
            是否可写
            </summary>
        </member>
        <member name="T:NewLife.Serialization.ReflectMemberInfo">
            <summary>
            反射成员信息
            </summary>
        </member>
        <member name="M:NewLife.Serialization.ReflectMemberInfo.#ctor(System.Reflection.MemberInfo)">
            <summary>
            实例化
            </summary>
            <param name="member"></param>
        </member>
        <member name="M:NewLife.Serialization.ReflectMemberInfo.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.Mix">
            <summary>快速反射</summary>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.Name">
            <summary>
            名称
            </summary>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.Type">
            <summary>
            类型
            </summary>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.Item(System.Object)">
            <summary>
            对目标对象取值赋值
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.CanRead">
            <summary>
            是否可读
            </summary>
        </member>
        <member name="P:NewLife.Serialization.ReflectMemberInfo.CanWrite">
            <summary>
            是否可写
            </summary>
        </member>
        <member name="T:NewLife.Serialization.JsonSettings">
            <summary>
            Json设置
            </summary>
        </member>
        <member name="M:NewLife.Serialization.JsonSettings.#ctor">
            <summary>
            实例化
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.Indent">
            <summary>缩进</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.JsonDateTimeFormat">
            <summary>
            指定日期时间输出成什么格式,具体格式说明见JsonDateTimeWriteFormat,默认是ISO8601格式
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.JsonDateTimeKind">
            <summary>
            指定日期时间输出成什么时间,本地还是UTC时间,默认是UTC时间
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.UseStringUnicodeEncode">
            <summary>
            是否编码字符串中Unicode字符为\uXXXX的格式
            
            可以避免乱码问题,但是会增加数据长度
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.AllowMultiline">
            <summary>
            是否允许输出多行结果,这会便于阅读结果,当为false时可以用作jsonp回调(还需要做字符串转义)
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.DuplicatedObjectWriteMode">
            <summary>
            重复对象的处理方式,仅用于JsonWriter,默认是深度限制,使用DepthLimit执行的深度
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.DepthLimit">
            <summary>
            复合对象的解析深度限制,只有在DuplicatedObjectWriteMode是DuplicatedObjectWriteMode.DepthLimit时生效
            
            复合对象主要是[]和{}的对象,可能是数组 集合 字典 自定义类型
            
            对于JsonWriter,默认值是16(调试时5). 对于JsonReader,默认值是1000(调试时10)
            
            关于1000的取值,测试调用堆栈极限程序中大概12273次调用时抛出StackOverflowException异常,而每处理一个ReadObject大概需要9个调用
            </summary>
        </member>
        <member name="P:NewLife.Serialization.JsonSettings.UseCharsWriteToString">
            <summary>
            是否将char[]输出为string,这会减少数据长度,仅会影响JsonWriter,默认true
            </summary>
        </member>
        <member name="T:NewLife.Serialization.JsonDateTimeWriteFormat">
            <summary>
            json序列化时用于指定日期时间输出成什么格式
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonDateTimeWriteFormat.ISO8601">
            <summary>
            ISO 8601格式 类似"2011-05-05T05:12:19.123Z"格式的UTC时间
            
            在http://goo.gl/RZoaz中有js端实现,并且在ie8(ie8模式) ff3.5之后都内建提供toJSON()实现
            
            这也是默认格式
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonDateTimeWriteFormat.DotnetDateTick">
            <summary>
            dotnet3.5中System.Web.Script.Serialization.JavaScriptSerializer输出的格式
            
            类似"\/Date(1304572339844)\/"格式的从 UTC 1970.1.1 午夜开始已经经过的毫秒数
            </summary>
        </member>
        <member name="F:NewLife.Serialization.JsonDateTimeWriteFormat.Tick">
            <summary>
            数字,具体值依赖于DateTimeFormat的配置
            </summary>
        </member>
        <member name="T:NewLife.Serialization.DuplicatedObjectWriteMode">
            <summary>
            重复对象的处理方式
            </summary>
        </member>
        <member name="F:NewLife.Serialization.DuplicatedObjectWriteMode.DepthLimit">
            <summary>
            限制处理复合对象的深度
            </summary>
        </member>
        <member name="F:NewLife.Serialization.DuplicatedObjectWriteMode.ObjectRef">
            <summary>
            对象引用方式,暂未实现
            </summary>
        </member>
        <member name="T:NewLife.Serialization.BinaryWriterX">
            <summary>
            二进制写入器
            </summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Write(System.Byte)">
            <summary>
            写入字节
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将字节数组部分写入当前流。
            </summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="index">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteIntBytes(System.Byte[])">
            <summary>
            判断字节顺序
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Write(System.Int16)">
            <summary>
            将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。
            </summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Write(System.Int32)">
            <summary>
            将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。
            </summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Write(System.Int64)">
            <summary>
            将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。
            </summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteEncoded(System.Int16)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value"></param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteEncoded(System.Int32)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value"></param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteEncoded(System.Int64)">
            <summary>
            以7位压缩格式写入64位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value"></param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.OnWriteType(System.Type)">
            <summary>
            写入Type
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteRefObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写对象
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.OnWriteMember(System.Object,System.Type,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入成员
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.WriteEnumerable(System.Collections.IEnumerable,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入枚举数据，复杂类型使用委托方法进行处理
            </summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.OnGetMembers(System.Type,System.Object)">
            <summary>
            获取需要序列化的成员
            </summary>
            <param name="type">类型</param>
            <param name="value">对象</param>
            <returns>需要序列化的成员</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.Flush">
            <summary>
            刷新缓存中的数据
            </summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryWriterX.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.BinaryWriterX.Writer">
            <summary>写入器</summary>
        </member>
        <member name="P:NewLife.Serialization.BinaryWriterX.Stream">
            <summary>
            数据流。更改数据流后，重置Writer为空，以使用新的数据流
            </summary>
        </member>
        <member name="T:NewLife.Collections.DictionaryCache`2">
            <summary>
            字典缓存。当指定键的缓存项不存在时，调用委托获取值，并写入缓存
            </summary>
            <typeparam name="TKey">键类型</typeparam>
            <typeparam name="TValue">值类型</typeparam>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem(`0,NewLife.Reflection.Func{`0,`1})">
            <summary>
            扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。
            </summary>
            <param name="key">键</param>
            <param name="func">获取值的委托，该委托以键作为参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem(`0,NewLife.Reflection.Func{`0,`1},System.Boolean)">
            <summary>
            扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。
            </summary>
            <param name="key">键</param>
            <param name="func">获取值的委托，该委托以键作为参数</param>
            <param name="cacheDefault">是否缓存默认值，可选参数，默认缓存</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``1(`0,``0,NewLife.Reflection.Func{`0,``0,`1})">
            <summary>
            扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。
            </summary>
            <typeparam name="TArg">参数类型</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有一个泛型参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``1(`0,``0,NewLife.Reflection.Func{`0,``0,`1},System.Boolean)">
            <summary>
            扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。
            </summary>
            <typeparam name="TArg">参数类型</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有一个泛型参数</param>
            <param name="cacheDefault">是否缓存默认值，可选参数，默认缓存</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``2(`0,``0,``1,NewLife.Reflection.Func{`0,``0,``1,`1})">
            <summary>
            扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。
            </summary>
            <typeparam name="TArg">参数类型</typeparam>
            <typeparam name="TArg2">参数类型2</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="arg2">参数2</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有两个泛型参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``2(`0,``0,``1,NewLife.Reflection.Func{`0,``0,``1,`1},System.Boolean)">
            <summary>
            扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。
            </summary>
            <typeparam name="TArg">参数类型</typeparam>
            <typeparam name="TArg2">参数类型2</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="arg2">参数2</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有两个泛型参数</param>
            <param name="cacheDefault">是否缓存默认值，可选参数，默认缓存</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``3(`0,``0,``1,``2,NewLife.Reflection.Func{`0,``0,``1,``2,`1})">
            <summary>
            扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。
            </summary>
            <typeparam name="TArg">参数类型</typeparam>
            <typeparam name="TArg2">参数类型2</typeparam>
            <typeparam name="TArg3">参数类型3</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="arg2">参数2</param>
            <param name="arg3">参数3</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有三个泛型参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem``3(`0,``0,``1,``2,NewLife.Reflection.Func{`0,``0,``1,``2,`1},System.Boolean)">
            <summary>
            扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。
            </summary>
            <typeparam name="TArg">参数类型</typeparam>
            <typeparam name="TArg2">参数类型2</typeparam>
            <typeparam name="TArg3">参数类型3</typeparam>
            <param name="key">键</param>
            <param name="arg">参数</param>
            <param name="arg2">参数2</param>
            <param name="arg3">参数3</param>
            <param name="func">获取值的委托，该委托除了键参数外，还有三个泛型参数</param>
            <param name="cacheDefault">是否缓存默认值，可选参数，默认缓存</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Item(`0)">
            <summary>
            重写索引器。取值时如果没有该项则返回默认值；赋值时如果已存在该项则覆盖，否则添加。
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Xml.ExtendData">
            <summary>
            扩展数据
            </summary>
        </member>
        <member name="M:NewLife.Xml.ExtendData.GetItem``1(System.String)">
            <summary>
            取得指定键的强类型值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.ExtendData.SetItem(System.String,System.Object)">
            <summary>
            设置类型
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Xml.ExtendData.Contain(System.String)">
            <summary>
            包含指定键
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.ExtendData.Remove(System.String)">
            <summary>
            移除指定项
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Xml.ExtendData.FromXml(System.String)">
            <summary>
            从Xml转为具体数据
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.ExtendData.ToXml">
            <summary>
            转为Xml
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Xml.ExtendData.Data">
            <summary>数据</summary>
        </member>
        <member name="P:NewLife.Xml.ExtendData.XmlKeys">
            <summary>Xml数据键值</summary>
        </member>
        <member name="P:NewLife.Xml.ExtendData.Root">
            <summary>根名称</summary>
        </member>
        <member name="P:NewLife.Xml.ExtendData.Item(System.String)">
            <summary>
            读取设置数据
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Xml.ExtendData.IsEmpty">
            <summary>
            是否为空
            </summary>
        </member>
        <member name="T:NewLife.Web.ControlHelper">
            <summary>
            控件助手
            </summary>
        </member>
        <member name="M:NewLife.Web.ControlHelper.FindControl``1(System.Web.UI.Control,System.String)">
            <summary>
            查找指定类型的子孙控件
            </summary>
            <typeparam name="T">目标控件类型</typeparam>
            <param name="control">父控件，从该控件开始向下进行广度搜索</param>
            <param name="id">控件ID，不指定表示不限制</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.ControlHelper.FindControlUp``1(System.Web.UI.Control,System.String)">
            <summary>
            查找指定控件附近的控件，向上搜索
            </summary>
            <typeparam name="T">目标控件类型</typeparam>
            <param name="control">指定控件</param>
            <param name="id">控件ID，不指定表示不限制</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.ControlHelper.FindControlInPage``1(System.String)">
            <summary>
            在页面查找指定ID的控件，采用反射字段的方法，避免遍历Controls引起子控件构造
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.ThreadX">
            <summary>
            线程扩展
            </summary>
        </member>
        <member name="F:NewLife.Threading.ThreadX.internalEvent">
            <summary>
            内部控制事件
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Start">
            <summary>
            开始
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Abort(System.Boolean)">
            <summary>
            取消
            </summary>
            <param name="onlytask">是否仅仅取消任务</param>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadX.Dispose(System.Boolean)">
            <summary>
            释放资源。非用户代码调用时，仅释放非托管资源
            </summary>
            <param name="disposing">是否用户代码调用</param>
        </member>
        <member name="M:NewLife.Threading.ThreadX.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadX.FindException``1(System.Exception)">
            <summary>
            查找指定类型的异常
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Task">
            <summary>任务</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.LastError">
            <summary>最后错误</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Running">
            <summary>是否正在处理任务</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.IsAlive">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.CanRelease">
            <summary>
            是否能够释放
            </summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Thread">
            <summary>线程</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.StartTime">
            <summary>开始时间</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.AliveTime">
            <summary>活动时间</summary>
        </member>
        <member name="E:NewLife.Threading.ThreadX.OnTaskFinished">
            <summary>任务完成时</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadX.Debug">
            <summary>
            是否调试
            </summary>
        </member>
        <member name="T:NewLife.Security.DataHelper">
            <summary>
            数据助手
            </summary>
        </member>
        <member name="M:NewLife.Security.DataHelper.Hash(System.String)">
            <summary>
            MD5散列
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.HashFile(System.String)">
            <summary>
            文件散列
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC16(System.IO.Stream)">
            <summary>
            CRC校验
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC16(System.Byte[])">
            <summary>
            CRC校验
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC16(System.String)">
            <summary>
            CRC校验文件
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC32(System.IO.Stream)">
            <summary>
            CRC校验
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC32(System.Byte[])">
            <summary>
            CRC校验
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.CRC32(System.String)">
            <summary>
            CRC校验文件
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Encrypt(System.String,System.String)">
            <summary>
            加密
            </summary>
            <param name="content"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Encrypt(System.Byte[],System.String)">
            <summary>
            加密
            </summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Descrypt(System.String,System.String)">
            <summary>
            解密
            </summary>
            <param name="content"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Descrypt(System.Byte[],System.String)">
            <summary>
            解密
            </summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.RC4(System.Byte[],System.String)">
            <summary>
            加密
            </summary>
            <param name="data">数据</param>
            <param name="pass">密码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.GetKey(System.Byte[],System.Int32)">
            <summary>
            打乱密码
            </summary>
            <param name="pass">密码</param>
            <param name="kLen">密码箱长度</param>
            <returns>打乱后的密码</returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Sign(System.Byte[],System.String)">
            <summary>
            签名
            </summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.Verify(System.Byte[],System.String,System.String)">
            <summary>
            验证签名
            </summary>
            <param name="data">待验证的数据</param>
            <param name="signdata">签名</param>
            <param name="pubKey">公钥</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.ToHex(System.Byte[])">
            <summary>
            加密
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DataHelper.FromHex(System.String)">
            <summary>
            解密
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.FieldInfoX">
            <summary>
            快速字段访问
            </summary>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.Create(System.Reflection.FieldInfo)">
            <summary>
            创建
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.Create(System.Type,System.String)">
            <summary>
            创建
            </summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.GetValue(System.Object)">
            <summary>
            取值
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.SetValue(System.Object,System.Object)">
            <summary>
            赋值
            </summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.GetValue``1(System.Object,System.String)">
            <summary>
            静态快速取值
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="target"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.GetValue``2(System.String)">
            <summary>
            快速获取静态字段
            </summary>
            <typeparam name="TTarget"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.SetValue(System.Object,System.String,System.Object)">
            <summary>
            静态快速赋值
            </summary>
            <param name="target"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.SetValue``1(System.String,System.Object)">
            <summary>
            快速设置静态字段
            </summary>
            <typeparam name="TTarget"></typeparam>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.op_Implicit(NewLife.Reflection.FieldInfoX)~System.Reflection.FieldInfo">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.FieldInfoX.op_Implicit(System.Reflection.FieldInfo)~NewLife.Reflection.FieldInfoX">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.FieldInfoX.Field">
            <summary>目标字段</summary>
        </member>
        <member name="P:NewLife.Reflection.FieldInfoX.GetHandler">
            <summary>
            快速调用委托，延迟到首次使用才创建
            </summary>
        </member>
        <member name="P:NewLife.Reflection.FieldInfoX.SetHandler">
            <summary>
            快速调用委托，延迟到首次使用才创建
            </summary>
        </member>
        <member name="T:NewLife.IO.ReadWriteMemoryStream">
            <summary>
            读写流，继承自内存流，读写指针分开
            </summary>
            <remarks>
            注意资源锁，读写不可同时进行，会出现抢锁的情况。
            </remarks>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.SeekForWrite(System.Int64,System.IO.SeekOrigin)">
            <summary>
            已重载。
            </summary>
            <param name="offset"></param>
            <param name="loc"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.ResetLength">
            <summary>
            重设长度，
            </summary>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            已重载。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.ReadByte">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            已重载。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.WriteByte(System.Byte)">
            <summary>
            已重载。
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.IO.ReadWriteMemoryStream.Dispose(System.Boolean)">
            <summary>
            资源释放，关闭事件量
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.ReadTimeout">
            <summary>获取或设置一个值（以毫秒为单位），该值确定流在超时前尝试读取多长时间。</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.PositionForWrite">
            <summary>写位置</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.MaxLength">
            <summary>最大长度，超过次长度时清空缓冲区</summary>
        </member>
        <member name="P:NewLife.IO.ReadWriteMemoryStream.AvailableData">
            <summary>可用数据</summary>
        </member>
        <member name="T:NewLife.Serialization.WriteItemEventArgs">
            <summary>
            写入枚举项事件参数
            </summary>
        </member>
        <member name="M:NewLife.Serialization.WriteItemEventArgs.#ctor(System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            实例化
            </summary>
            <param name="value">对象</param>
            <param name="type">对象类型</param>
            <param name="index">序号</param>
            <param name="callback"></param>
        </member>
        <member name="P:NewLife.Serialization.WriteItemEventArgs.Value">
            <summary>对象</summary>
        </member>
        <member name="P:NewLife.Serialization.WriteItemEventArgs.Type">
            <summary>对象类型</summary>
        </member>
        <member name="T:NewLife.Serialization.NameValueSetting">
            <summary>
            名值读写器设置
            </summary>
        </member>
        <member name="P:NewLife.Serialization.NameValueSetting.Separator">
            <summary>分隔符</summary>
        </member>
        <member name="P:NewLife.Serialization.NameValueSetting.Connector">
            <summary>连接符</summary>
        </member>
        <member name="T:NewLife.IO.Json">
            <summary>
            Json
            </summary>
        </member>
        <member name="M:NewLife.IO.Json.ConvertToType``1(System.Object)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.ConvertToType(System.Object,System.Type)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.Deserialize``1(System.String)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.Deserialize(System.String,System.Type)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.DeserializeObject(System.String)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.Serialize(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.Json.Serialize(System.Object,System.Text.StringBuilder)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="output"></param>
        </member>
        <member name="P:NewLife.IO.Json.MaxJsonLength">
            <summary>最大长度</summary>
        </member>
        <member name="P:NewLife.IO.Json.RecursionLimit">
            <summary>递归限制</summary>
        </member>
        <member name="T:NewLife.Serialization.WriteObjectCallback">
            <summary>
            数据写入方法
            </summary>
            <param name="writer">写入器</param>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="T:NewLife.Serialization.ReadObjectCallback">
            <summary>
            数据读取方法
            </summary>
            <param name="reader">读取器</param>
            <param name="type">要读取的对象类型</param>
            <param name="value">要读取的对象</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="T:NewLife.Model.ServiceProvider">
            <summary>
            服务对象提供者，优先查找从构造函数传入的外部提供者，然后是全局的Current，最后才是当前提供者
            </summary>
        </member>
        <member name="M:NewLife.Model.ServiceProvider.#ctor">
            <summary>
            实例化
            </summary>
        </member>
        <member name="M:NewLife.Model.ServiceProvider.#ctor(System.IServiceProvider)">
            <summary>
            通过指定一个基础提供者来实例化一个新的提供者，优先基础提供者
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:NewLife.Model.ServiceProvider.GetService``1(System.IServiceProvider)">
            <summary>
            获取服务对象的泛型实现，能够层层深入，处理无限层嵌套的服务提供者
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ServiceProvider.GetService(System.IServiceProvider,System.Type)">
            <summary>
            获取服务对象，能够层层深入，处理无限层嵌套的服务提供者
            </summary>
            <param name="provider"></param>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ServiceProvider.GetCurrentService``1">
            <summary>
            使用默认提供者获取服务对象的泛型实现
            </summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ServiceProvider.GetService(System.Type)">
            <summary>
            获取服务对象
            </summary>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ServiceProvider.GetService``1">
            <summary>
            获取服务对象的泛型实现
            </summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="P:NewLife.Model.ServiceProvider.Current">
            <summary>默认服务对象提供者</summary>
        </member>
        <member name="T:NewLife.Xml.XmlWriterX">
            <summary>
            Xml写入器
            </summary>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.Write(System.String)">
            <summary>
            写入字符串
            </summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteObjectType(System.Type)">
            <summary>
            写对象类型
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.OnWriteKeyValue(System.Collections.DictionaryEntry,System.Type,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入字典项
            </summary>
            <param name="value">对象</param>
            <param name="keyType">键类型</param>
            <param name="valueType">值类型</param>
            <param name="index">成员索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.OnWriteItem(System.Object,System.Type,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入枚举项
            </summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="index">成员索引</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteEnumerable(System.Collections.IEnumerable,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入枚举数据，复杂类型使用委托方法进行处理
            </summary>
            <param name="value">对象</param>
            <param name="type">类型</param>
            <param name="callback">使用指定委托方法处理复杂数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.OnWriteObject(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            已重载。写入文档的开头和结尾
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.OnWriteMember(System.Object,System.Type,NewLife.Serialization.IObjectMemberInfo,System.Int32,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入成员
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="member">成员</param>
            <param name="index">成员索引</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.OnWriteObjRefIndex(System.Int32)">
            <summary>
            写对象引用计数
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteUnKnown(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入未知对象（其它所有方法都无法识别的对象），采用BinaryFormatter或者XmlSerialization
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.Flush">
            <summary>
            刷新缓存中的数据
            </summary>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteLengths(System.String)">
            <summary>
            写入长度
            </summary>
            <param name="lengths"></param>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.WriteSerializable(System.Object,System.Type,NewLife.Serialization.WriteObjectCallback)">
            <summary>
            写入实现了可序列化接口的对象
            </summary>
            <param name="value">要写入的对象</param>
            <param name="type">要写入的对象类型，如果type等于DataTable，需设置DataTable的名称</param>
            <param name="callback">处理成员的方法</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:NewLife.Xml.XmlWriterX.IsAttributeType(System.Type)">
            <summary>
            是否可以作为属性写入Xml的类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Xml.XmlWriterX.Writer">
            <summary>写入器</summary>
        </member>
        <member name="P:NewLife.Xml.XmlWriterX.Stream">
            <summary>
            数据流。更改数据流后，重置Writer为空，以使用新的数据流
            </summary>
        </member>
        <member name="P:NewLife.Xml.XmlWriterX.RootName">
            <summary>根元素名</summary>
        </member>
        <member name="T:NewLife.Web.WebHelper">
            <summary>
            网页工具类
            </summary>
        </member>
        <member name="M:NewLife.Web.WebHelper.WriteScript(System.String)">
            <summary>
            输出脚本
            </summary>
            <param name="script"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.GetSubString(System.String,System.Int32,System.Int32)">
            <summary>
            按字节截取
            </summary>
            <param name="Str">字符串</param>
            <param name="StartIndex">开始位置</param>
            <param name="Len">长度</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.JsEncode(System.String)">
            <summary>
            Js脚本编码
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.Alert(System.String)">
            <summary>
            弹出页面提示
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndEnd(System.String)">
            <summary>
            弹出页面提示并停止输出后退一步！
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndRefresh(System.String)">
            <summary>
            弹出页面提示，并刷新该页面
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndRedirect(System.String,System.String)">
            <summary>
            弹出页面提示并重定向到另外的页面
            </summary>
            <param name="msg"></param>
            <param name="url"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndClose(System.String)">
            <summary>
            弹出页面提示并关闭当前页面
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.CheckEmptyAndFocus(System.Web.UI.Control,System.String)">
            <summary>
            检查控件值是否为空，若为空，显示错误信息，并聚焦到控件上
            </summary>
            <param name="control">要检查的控件</param>
            <param name="errmsg">错误信息。若为空，将使用ToolTip</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.ExportExcel(System.Web.UI.WebControls.GridView,System.String,System.Int32)">
            <summary>
            导出Excel
            </summary>
            <param name="gv"></param>
            <param name="filename"></param>
            <param name="max"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.ExportExcel(System.Web.UI.WebControls.GridView,System.String,System.Int32,System.Text.Encoding)">
            <summary>
            导出Excel
            </summary>
            <param name="gv"></param>
            <param name="filename"></param>
            <param name="max"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.RequestInt(System.String)">
            <summary>
            获取整型参数
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.RequestBool(System.String)">
            <summary>
            接收布尔值
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.RequestDateTime(System.String)">
            <summary>
            接收时间
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.RequestDouble(System.String)">
            <summary>
            接收Double
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.ConvertInt(System.String)">
            <summary>
            字符转换为数字
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.ConvertBool(System.String)">
            <summary>
            字符转换为布尔
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.ConvertDateTime(System.String)">
            <summary>
            字符转换为时间
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.ConvertDouble(System.String)">
            <summary>
            字符转换
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.WebHelper.UserHost">
            <summary>
            用户主机
            </summary>
        </member>
        <member name="T:NewLife.Serialization.NameValueWriter">
            <summary>
            名值写入器。用于Http请求、Http接口响应、Cookie值等读写操作。
            </summary>
        </member>
        <member name="T:NewLife.Serialization.NameValueReader">
            <summary>
            名值读取器。用于Http请求、Http接口响应、Cookie值等读写操作。
            </summary>
        </member>
        <member name="T:NewLife.IO.IOHelper">
            <summary>
            IO工具类
            </summary>
        </member>
        <member name="M:NewLife.IO.IOHelper.Compress(System.IO.Stream,System.IO.Stream)">
            <summary>
            压缩
            </summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流</param>
        </member>
        <member name="M:NewLife.IO.IOHelper.Decompress(System.IO.Stream,System.IO.Stream)">
            <summary>
            解压缩
            </summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流</param>
        </member>
        <member name="M:NewLife.IO.IOHelper.Compress(System.Byte[])">
            <summary>
            压缩
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.Decompress(System.Byte[])">
            <summary>
            解压缩
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.CompressFile(System.String,System.String)">
            <summary>
            压缩单个文件，纯文件流压缩
            </summary>
            <param name="src"></param>
            <param name="des"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.CompressFile(System.String)">
            <summary>
            压缩目录
            </summary>
            <param name="root"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.CompressFile(System.String,System.String[])">
            <summary>
            压缩多个文件
            </summary>
            <param name="root">根目录</param>
            <param name="files">文件集合</param>
            <returns>压缩的文件名</returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.CompressFile(System.String,System.String[],System.String)">
            <summary>
            压缩多个文件
            </summary>
            <param name="root">根目录</param>
            <param name="files">文件集合</param>
            <param name="des">输出文件</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.CompressFile(System.String,System.String[],System.IO.Stream)">
            <summary>
            压缩多个文件，每个文件流之前都写入相对文件路径（包括相对于根目录）和文件长度等头部信息
            </summary>
            <param name="root">根目录</param>
            <param name="files">文件集合</param>
            <param name="outStream">目标</param>
        </member>
        <member name="M:NewLife.IO.IOHelper.DecompressSingleFile(System.String,System.String)">
            <summary>
            解压缩单个文件，纯文件流解压缩
            </summary>
            <param name="src"></param>
            <param name="des"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.DecompressFile(System.String,System.String,System.Boolean)">
            <summary>
            解压缩，并指定是否解压到子目录中
            </summary>
            <param name="src"></param>
            <param name="targetPath"></param>
            <param name="isSub">是否解压到子目录中，仅对多文件有效</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.DecompressFile(System.String,System.String)">
            <summary>
            解压缩
            </summary>
            <param name="src"></param>
            <param name="targetPath"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.DecompressFile(System.IO.Stream,System.String)">
            <summary>
            解压缩多个文件
            </summary>
            <param name="inStream"></param>
            <param name="targetPath"></param>
        </member>
        <member name="M:NewLife.IO.IOHelper.DecompressFile(System.IO.Stream,System.String,System.String,System.Boolean)">
            <summary>
            解压缩。如果单文件，就解压到targetPath下的des文件；如果多文件，就解压到targetPath的des子目录下，此时des可以为空。
            </summary>
            <param name="inStream"></param>
            <param name="targetPath"></param>
            <param name="des">多文件时，指代子目录，为空表示当前目录；单文件时表示目标文件</param>
            <param name="isSub">是否解压到子目录中，仅对多文件有效</param>
        </member>
        <member name="M:NewLife.IO.IOHelper.CopyTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            复制数据流
            </summary>
            <param name="src">源数据流</param>
            <param name="des">目的数据流</param>
            <returns>返回复制的总字节数</returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.CopyTo(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>
            复制数据流
            </summary>
            <param name="src">源数据流</param>
            <param name="des">目的数据流</param>
            <param name="bufferSize">缓冲区大小，也就是每次复制的大小</param>
            <returns>返回复制的总字节数</returns>
        </member>
        <member name="M:NewLife.IO.IOHelper.CopyTo(System.IO.Stream,System.IO.Stream,System.Int32,System.Int32)">
            <summary>
            复制数据流
            </summary>
            <param name="src">源数据流</param>
            <param name="des">目的数据流</param>
            <param name="bufferSize">缓冲区大小，也就是每次复制的大小</param>
            <param name="max">最大复制字节数</param>
            <returns>返回复制的总字节数</returns>
        </member>
        <member name="T:NewLife.IO.BinaryTest">
            <summary>
            二进制操作测试
            </summary>
        </member>
        <member name="M:NewLife.IO.BinaryTest.Test">
            <summary>
            测试
            </summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.ID">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.Name">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.ByteProperty">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.Time">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.Consolekey">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.Guid">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.Address">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.Remote">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.Bytes">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.ByteList">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.IO.BinaryTest.Dic">
            <summary>属性说明</summary>
        </member>
        <member name="T:NewLife.Configuration.Config">
            <summary>
            通用配置辅助类
            </summary>
        </member>
        <member name="M:NewLife.Configuration.Config.Contain(System.String)">
            <summary>
            是否包含指定项的设置
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfig``1(System.String)">
            <summary>
            取得指定名称的设置项，并转为指定类型
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfig``1(System.String,``0)">
            <summary>
            取得指定名称的设置项，并转为指定类型。如果设置不存在，则返回默认值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfigByPrefix(System.String)">
            <summary>
            根据指定前缀，获取设置项
            </summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfigSplit``1(System.String,System.String)">
            <summary>
            取得指定名称的设置项，并分割为指定类型数组
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfigSplit``1(System.String,System.String,``0[])">
            <summary>
            取得指定名称的设置项，并分割为指定类型数组
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="split"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Configuration.Config.AppSettings">
            <summary>应用设置</summary>
        </member>
        <member name="P:NewLife.Configuration.Config.ConnectionStrings">
            <summary>连接字符串设置</summary>
        </member>
    </members>
</doc>
